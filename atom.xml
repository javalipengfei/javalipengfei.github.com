<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[漫步云端]]></title>
  <link href="http://javalipengfei.github.io/atom.xml" rel="self"/>
  <link href="http://javalipengfei.github.io/"/>
  <updated>2014-04-03T10:25:18+08:00</updated>
  <id>http://javalipengfei.github.io/</id>
  <author>
    <name><![CDATA[李鹏飞]]></name>
    <email><![CDATA[javalipengfei@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[objc 文章汇总]]></title>
    <link href="http://javalipengfei.github.io/blog/2014/03/27/objc-wen-zhang-hui-zong/"/>
    <updated>2014-03-27T11:07:00+08:00</updated>
    <id>http://javalipengfei.github.io/blog/2014/03/27/objc-wen-zhang-hui-zong</id>
    <content type="html"><![CDATA[<h3>昨天发现一个翻译小组已经把文章全部翻译出来了，质量比我的强多了，太伟大了，给32个赞。这是汇总的<a href="http://objccn.io">网址</a>,慢慢学习中。</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[并发编程:APIs和挑战]]></title>
    <link href="http://javalipengfei.github.io/blog/2014/03/24/bing-fa-bian-cheng-apishe-tiao-zhan/"/>
    <updated>2014-03-24T17:50:00+08:00</updated>
    <id>http://javalipengfei.github.io/blog/2014/03/24/bing-fa-bian-cheng-apishe-tiao-zhan</id>
    <content type="html"><![CDATA[<h4><a href="http://twitter.com/floriankugler">作者</a></h4>

<h4><a href="http://en.wikipedia.org/wiki/Concurrency_%28computer_science%29">并发</a>是指一系列任务在同一时间运行。这个即可能发生在基于<a href="http://en.wikipedia.org/wiki/Preemption_%28computing%29">时间分享</a>管理的单核cup核心上，<!--more-->或者真正的并行发生在多核cup上。</h4>

<h4>OSX和IOS提供了几个不同的APIS确保并发编程。这些APIS中的每一个都有不同的能力和限制，要合理的使用他们。他们也被归为不同的抽象水平。我们的操作性可能非常的灵活，但是这同时也带来了巨大的责任把事情做好。</h4>

<h4>并发编程是一个充满很多的问题和陷阱的复杂课题，并且当我们使用APIS像Grand Central Dispatch 或者NSOperationQueue的时候我们很容易忘记这些问题和陷阱。这一系列文章首先将会概述一下不同的并发APIS在OS X和IOS，然后深入研究并发编程的固有挑战,独立于特定的API的使用。</h4>

<h3><center>OS X和IOS系统上的并发接口</center></h3>

<h4>苹果移动设备和桌面操作系统提供了同样的接口对于并发编程。在这篇文章我们将会研究一下pthread和NSthread，Grand Central Dispatch，NSOperationQueue，和NSRunLoop。从技术上讲，run loops是古怪的出现在这个列表中。因为他们不是真正的一类。但是他们足够的相近值得我们去研究一下。</h4>

<h4>我们先从低级别的APIS开始然后升级到高级别的APIS。我们选择这个方式因为高级别的APIS都是建立在低级别的APIS的。然而，当你在你的使用中选择APIS的时候。你应该还要考虑选择相反的：选择高级别的抽象APIS可以完成工作并可去可以使并发模型更简单。</h4>

<h4>如果你想知道为什么我们如此持久推荐高层抽象和非常简单的并发代码,你应该读这篇文章的第二部分。</h4>

<h3><center>线程</center></h3>

<h4>线程是进程的的一部分，它可以独立的运行通过操作系统的调度。事实上，几乎所有的并发api在线程之上构建底层——这是真正的中央调度和操作队列。</h4>

<h4>许多线程可以被执行在单核CPU在同一时间(或者视为在同一时间)。操作系统分配一些小的计算时间给每一个线程，所以多任务的时候是同时执行的。假如是多核CPU，这些线程就可以真正的并行运行，因此减轻某些工作负载所需的总时间。</h4>

<h4>你可以使用在xocde上的工具Instruments中的CPU strategy view 看到你的代码或者你使用的系统代码如何被调度运行的在多核的CPU上。</h4>

<h4>你要记住的一件很重要的事，你无法控制何时何地你的代码会被调度，并且何时和多长时间他开始暂停为了让别的任务运行。这种线程调度是一种非常强的技术。无论怎样，我们之后将会研究他的复杂性。</h4>

<h4>先把复杂的问题放到一边，你可以使用POSIX thread APS或者Objective-C所描述的API，NSThread，去创建你自己的线程。这里有一个小例子是关于使用线程找到1百万个数中找到最大和最小的值。将会产生4个线程并行运行。下面这个例子很显然表明为什么不会直接使用pthreads。</h4>

<pre><code>struct threadInfo {
uint32_t * inputValues;
size_t count;
};

struct threadResult {
    uint32_t min;
    uint32_t max;
};

void * findMinAndMax(void *arg)
{
    struct threadInfo const * const info = (struct threadInfo *) arg;
    uint32_t min = UINT32_MAX;
    uint32_t max = 0;
    for (size_t i = 0; i &lt; info-&gt;count; ++i) {
        uint32_t v = info-&gt;inputValues[i];
        min = MIN(min, v);
        max = MAX(max, v);
    }
    free(arg);
    struct threadResult * const result = (struct threadResult *)    malloc(sizeof(*result));
    result-&gt;min = min;
    result-&gt;max = max;
    return result;
}

int main(int argc, const char * argv[])
{
    size_t const count = 1000000;
    uint32_t inputValues[count];

    // Fill input values with random numbers:
    for (size_t i = 0; i &lt; count; ++i) {
        inputValues[i] = arc4random();
    }

    // Spawn 4 threads to find the minimum and maximum:
    size_t const threadCount = 4;
    pthread_t tid[threadCount];
    for (size_t i = 0; i &lt; threadCount; ++i) {
        struct threadInfo * const info = (struct threadInfo *)malloc(sizeof(*info));
        size_t offset = (count / threadCount) * i;
        info-&gt;inputValues = inputValues + offset;
        info-&gt;count = MIN(count - offset, count / threadCount);
        int err = pthread_create(tid + i, NULL, &amp;findMinAndMax, info);
        NSCAssert(err == 0, @"pthread_create() failed: %d", err);
    }
    // Wait for the threads to exit:
    struct threadResult * results[threadCount];
    for (size_t i = 0; i &lt; threadCount; ++i) {
        int err = pthread_join(tid[i], (void **) &amp;(results[i]));
        NSCAssert(err == 0, @"pthread_join() failed: %d", err);
    }
    // Find the min and max:
    uint32_t min = UINT32_MAX;
    uint32_t max = 0;
    for (size_t i = 0; i &lt; threadCount; ++i) {
        min = MIN(min, results[i]-&gt;min);
        max = MAX(max, results[i]-&gt;max);
        free(results[i]);
        results[i] = NULL;
    }

    NSLog(@"min = %u", min);
    NSLog(@"max = %u", max);
    return 0;
    }
</code></pre>

<h4>NSThread 是Objective—c围绕phtreads的封装。这让代码看起来更像是cocoa 的环境下的。例如，你可以定义一个线程作为NSThread的子类，他将会隐藏3一些代码以至于在后台运行，之前的例子我们可以定义NSThread的子类像这样：</h4>

<pre><code>@interface FindMinMaxThread : NSThread
@property (nonatomic) NSUInteger min;
@property (nonatomic) NSUInteger max;
- (instancetype)initWithNumbers:(NSArray *)numbers;
@end

@implementation FindMinMaxThread {
    NSArray *_numbers;
}

- (instancetype)initWithNumbers:(NSArray *)numbers 
{
    self = [super init];
    if (self) {
     _numbers = numbers;
    }
    return self;
}

- (void)main
{
    NSUInteger min;
    NSUInteger max;
    // process the data
    self.min = min;
    self.max = max;
}
@end
</code></pre>

<h4>为了启动这个线程，我们需要线程对象调用他的start方法：</h4>

<pre><code>NSSet *threads = [NSMutableSet set];
NSUInteger numberCount = self.numbers.count;
NSUInteger threadCount = 4;
for (NSUInteger i = 0; i &lt; threadCount; i++) {
    NSUInteger offset = (count / threadCount) * i;
    NSUInteger count = MIN(numberCount - offset, numberCount / threadCount);
    NSRange range = NSMakeRange(offset, count);
    NSArray *subset = [self.numbers subarrayWithRange:range];
    FindMinMaxThread *thread = [[FindMinMaxThread alloc]    initWithNumbers:subset];
    [threads addObject:thread];
    [thread start];
}
</code></pre>

<h4>现在我们可以通过观察thread的isFinished的属性知道何时我们新的线程结束在它评估结果之前。我们将把这个练习感兴趣的读者。重要的是使用线程pthread相对于NSThreadAPIS，是一个相对笨重的经验不适合我们的编码模型。</h4>

<h4>出现一个问题,可以直接使用线程是活动线程的数量成倍增加,如果你的代码和底层框架代码生成自己的线程。这实际上是一个相当普遍的问题在大项目。例如,如果您创建8线程利用8个CPU核心,从这些线程和框架代码调用做了同样的事情(因为它不知道您已经创建的线程),您可以快速与几十个甚至几百个线程。每个代码负责任地参与本身的一部分,然而,最终的结果是有问题的。线程不免费的。每个线程内核内存和资源的关系。</h4>

<h4>接下来,我们将讨论两个队列并发api:Grand Central Dispatch 和operation queues.。他们解决这个问题通过集中管理线程池,每个人都使用协作。</h4>

<h3><center>未完待续。。。。。</center></h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[测试视图控制器(续)]]></title>
    <link href="http://javalipengfei.github.io/blog/2014/03/17/ce-shi-shi-tu-kong-zhi-qi-xu/"/>
    <updated>2014-03-17T11:23:00+08:00</updated>
    <id>http://javalipengfei.github.io/blog/2014/03/17/ce-shi-shi-tu-kong-zhi-qi-xu</id>
    <content type="html"><![CDATA[<h3>测试数据源</h3>

<h4>现在让我们开始。分离视图控制器让我们的测试变得更简单。现在我们测试<h5>ArrayyDataSource</h5>.<h4><!--more-->首先。我们创建一个新的空的设置。我们把接口和实现放到同一个文件里；不需要包含任何的<h5>@interface</h5>.它会使这个文件更漂亮和简洁:</h4>

<pre><code>#import "PhotoDataTestCase.h"

@interface ArrayDataSourceTest : PhotoDataTestCase
@end

@implementation ArrayDataSourceTest
- (void)testNothing;
{
    STAssertTrue(YES, @"");
}
@end    
</code></pre>

<h4>不需要做太多的事情。这里展示的是测试基类设置。当运行这个测试的时候，这个testNothing方法将会运行。这个STAsser宏将会做检查。注意已ST开头的宏来自SenTestingKIt。这些整合在Xcode当中它会使故障显示在问题导航仪。</h4>

<h3>我们的第一个测试</h3>

<h4>我们替换textNothing方法通过这个例子。这是真正的测试：</h4>

<pre><code>- (void)testInitializing;
{
    STAssertNil([[ArrayDataSource alloc] init], @"Should not be allowed.");

    TableViewCellConfigureBlock block = ^(UITableViewCell *a, id b){};

    id obj1 = [[ArrayDataSource alloc] initWithItems:@[]
                                  cellIdentifier:@"foo"
                              configureCellBlock:block];
     STAssertNotNil(obj1, @"");
</code></pre>

<p>}</p>

<h3>Mocking实践</h3>

<h4>接下来。我们将会在ArrayDataSource的实现方法中测试- (UITableViewCell <em>)tableView:(UITableView </em>)tableView  cellForRowAtIndexPath:(NSIndexPath *)indexPath;这个方法。我先要创建一个- (void)testCellConfiguration;的测试方法。首先我们创建一个数据源：</h4>

<pre><code>__block UITableViewCell *configuredCell = nil;

__block id configuredObject = nil;

TableViewCellConfigureBlock block = ^(UITableViewCell *a, id b){

configuredCell = a;

configuredObject = b;

}
;
ArrayDataSource *dataSource = [[ArrayDataSource alloc]                                  initWithItems:@[@"a", @"b"]                                     cellIdentifier:@"foo"
                                configureCellBlock:block];
</code></pre>

<h4>注意这个configureCellBlock不会存储任何希望被存储的对象这让我们非常容易测试。</h4>

<h4>接下来我们会创建一个mock对象为tableVIew：</h4>

<pre><code>id mockTableView = [OCMockObject mockForClass:[UITableView class]];
</code></pre>

<h4>数据源将会被调用通过dequeueReusableCellWithIdentifier:forIndexPath:在tableview中。我们会通知mock对象应该做什么当得到这个消息的时候。我们首先创建一个cell并且设置mock：</h4>

<pre><code>UITableViewCell *cell = [[UITableViewCell alloc] init];

NSIndexPath* indexPath = [NSIndexPath indexPathForRow:0 inSection:0];

[[[mockTableView expect] andReturn:cell]
    dequeueReusableCellWithIdentifier:@"foo"
                         forIndexPath:indexPath];
</code></pre>

<h4>起初看起来这有些混乱。这是怎么回事，是让mock记录这个特殊的通知。这个mock不是一个tableview；我们仅仅假装它是。这个特别期望的方法允许我们去设置这个mock对象以至于当它被调用的时候我们知道发生了什么。此外。这个expect方法告诉mock的调用已经发生了。当我们在mock中之后调用-verify，假如方法没有被调用测试将会失败。这个相应的-stub方法也可以设置mock对象。但是不会在乎方法是否会被调用。</h4>

<h4>现在我们要出发代码去运行。我们会调用我们想要测试的方法：</h4>

<pre><code> SIndexPath* indexPath = [NSIndexPath indexPathForRow:0 inSection:0];

id result = [dataSource tableView:mockTableView
        cellForRowAtIndexPath:indexPath];
</code></pre>

<h4>这时我们会顺利测试：</h4>

<pre><code>STAssertEquals(result, cell, @"Should return the dummy cell.");

STAssertEquals(configuredCell, cell, @"This should have been passed to the  block.");

STAssertEqualObjects(configuredObject, @"a", @"This should have been passed     to the block.");

[mockTableView verify];
</code></pre>

<h4>这个STAssert测试的值将会相同。注意我们用指针对照第一个的两个测试。我们不想用—isEqual：方法。我们完全想知道这个result和cell和configuredCell是同一个对象。底仓额测试用-isEqual：并且最后我们调用了-Verify通过mock对象。注意这个例子，我们设置了mock对象通过id mockTableView = [self autoVerifiedMockForClass:[UITableView class]];</h4>

<h4>这是一个方便的包装在我们的测试基类，它会自动调用，验证在测试结束。</h4>

<h3><center>测试UITableview</center></h3>

<h4>下面,我们来看PhotosViewControllers。他是UItableviewController的子类并且他使用我们测试的数据源。这里的代码是非常简单的。我想将要测试一下点击一个cell进入详细页面。即一个PhotoViewContorller被推入到Navigation Controller。我们将会使用mocking以便我们对其他的部分依赖更小。</h4>

<h4>首先。我们创建一个UINavigationController 的对象：</h4>

<pre><code> id mockNavController = [OCMockObject mockForClass:[UINavigationController class]];
</code></pre>

<h4>下一步，我们将会使用局部的mocking。我们想要我们的PhotosViewController实例返回mockNavcontroller 作为他的navigationController。我们不能直接设置navigation controller。我们可以简单的 stub 这个方法去返回我们的mockNavigation 并且转发PhotosViewController实例：</h4>

<pre><code> PhotosViewController *photosViewController = [[PhotosViewController alloc] init];
 id photosViewControllerMock = [OCMockObject    partialMockForObject:photosViewController];
 [[[photosViewControllerMock stub] andReturn:mockNavController]     navigationController];
</code></pre>

<h4>现在，当navigationController方法调用photosViewController的时候。将会返回mockNavCOntroller。这将非常简洁和方便。</h4>

<h4>我们现在告诉mock的navigation controller 我们要用它做什么。即一个详细的带有photo变量的视图控制器设置为非空值，并且push这个视图。</h4>

<pre><code>UIViewController* viewController = [OCMArg checkWithBlock:^BOOL(id obj) {
PhotoViewController *vc = obj;
return ([vc isKindOfClass:[PhotoViewController class]] &amp;&amp;
        (vc.photo != nil));
}];
[[mockNavController expect] pushViewController:viewController animated:YES];
</code></pre>

<h4>现在我们出发这个视图加载并且模拟row被点击：</h4>

<pre><code>UIView *view = photosViewController.view;
STAssertNotNil(view, @"");
NSIndexPath* indexPath = [NSIndexPath indexPathForRow:0 inSection:0];
[photosViewController tableView:photosViewController.tableView 
    didSelectRowAtIndexPath:indexPath];
</code></pre>

<h4>最后我们要验证我们是否调用了mock的方法；</h4>

<pre><code>[mockNavController verify];
[photosViewControllerMock verify];
</code></pre>

<h4>我们现在已经测试了与navigation controller的互动并且创建了一个正确的视图控制器。</h4>

<h4>另外。在示例工程中，我们使用了我们自己的方便的方法。</h4>

<pre><code>- (id)autoVerifiedMockForClass:(Class)aClass;
- (id)autoVerifiedPartialMockForObject:(id)object;
</code></pre>

<h4>以便于不用必须记住调用-verify方法。</h4>

<h3><center>未来的可能性</center></h3>

<h4>正如上面看到的。partitral mocking 是非常强大的。如果你仔细查看-[PhotosViewController setupTableView] 的源代码。你会发现如何得到一个模型对象通过app的代理：</h4>

<pre><code>NSArray *photos = [AppDelegate sharedDelegate].store.sortedPhotos;
</code></pre>

<h4>上面的测试依赖这个。通过使用parital mocking 创建一个app delegate 返回预定义的数据可以打破这种依赖。像这样：</h4>

<pre><code>id storeMock; // assume we've set this up
id appDelegate = [AppDelegate sharedDelegate]
id appDelegateMock = [OCMockObject partialMockForObject:appDelegate];
[[[appDelegateMock stub] andReturn:storeMock] store];
</code></pre>

<h4>现在 无论何时[AppDelegate sharedDelegate].store 被调用，它都会返回sotreMock。这是一种极端的方式。确保保持你的测试越来越简单当测试特别复杂的时候。</h4>

<h3><center>需要记住的事情</center></h3>

<h4>partial mocks 伪造的对象一直存在他们的周围。你可以提前停止他们的行为通过调用[aMock stopMocking].大部分时间，你想要这个partial mock 保持活跃在测试时间。确保[aMock verify]在测试的结尾被调用。否则ARC 也许会更早的释放mock 。你应该尽可以能的-verify。</h4>

<h3><center>测试nib的加载</center></h3>

<h4>photoCell 将会在NIB设置。我们可以写一个简单的测试检测插座变量设置是否正确。让我们看一下photocell类。</h4>

<pre><code>@interface PhotoCell : UITableViewCell
+ (UINib *)nib;
@property (weak, nonatomic) IBOutlet UILabel* photoTitleLabel;
@property (weak, nonatomic) IBOutlet UILabel* photoDateLabel;
@end
</code></pre>

<h4>我们简单测试如下：</h4>

<pre><code>@implementation PhotoCellTests

- (void)testNibLoading;
{
    UINib *nib = [PhotoCell nib];
    STAssertNotNil(nib, @"");

    NSArray *a = [nib instantiateWithOwner:nil options:@{}];
    STAssertEquals([a count], (NSUInteger) 1, @"");
    PhotoCell *cell = a[0];
    STAssertTrue([cell isMemberOfClass:[PhotoCell class]], @"");

    // Check that outlets are set up correctly:
    STAssertNotNil(cell.photoTitleLabel, @"");
    STAssertNotNil(cell.photoDateLabel, @"");
}

@end
</code></pre>

<h4>非常基础，但是实用。</h4>

<h4>一个争论是我们现实是否需要同时更新测试和类/nib 当我们改变事情的时候。答案是肯定的。我们需要估量一下针对破坏插座变量的可能性。假如你用的的是.xib文件。你会发现这是经常发生的事情。</h4>

<h3><center>额外的思考</center></h3>

<h4>假如你有一个持续集成的解决方案。使用测试是一个非常好的注意。细节已经超出了本文的范围。该脚本由RunUnitTests脚本触发，并有一个TEST_AFTER_BUILD环境变量。另一个有趣的话题是创建一个独立的测试包的自动化性能测试。你可以自由地做任何你想要在你的测试方法。时序某些呼叫和使用STAssert检查他们是一个特定的阈值之内将是一个选项。</h4>

<h3><center>翻译的很水 要是有不对的地方 欢迎指正</center></h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[测试视图控制器]]></title>
    <link href="http://javalipengfei.github.io/blog/2014/03/15/ce-shi-shi-tu-kong-zhi-qi/"/>
    <updated>2014-03-15T15:52:00+08:00</updated>
    <id>http://javalipengfei.github.io/blog/2014/03/15/ce-shi-shi-tu-kong-zhi-qi</id>
    <content type="html"><![CDATA[<h4>来源<a href="http://www.objc.io/issue-1/testing-view-controllers.html">objc.</a></h4>

<h4>作者<a href="https://twitter.com/danielboedewadt">Daniel Eggert</a></h4>

<h3>保持事情简单</h3>

<h4>测试简单的事情就会简单，测试复杂的事情就会变得复杂。正如我们在前几篇文章中指出的，保持事情小而且简单通常来说是非常好的。同时对于测试也很有帮助。他是双赢的结果。一起来看看<a href="https://en.wikipedia.org/wiki/Test-driven_development">测试驱动开发</a>，有些人喜欢他，有些人反之。我们不会去深入细节在这里，但是我们会说一下测试驱动开发，关于在你写代码之前你写的测试为你的代码。假如你对测试驱动开发好奇的话，查阅维基百科的资料你会发现重构和测试会很好的结合在一起。<!--more--></h4>

<h4>测试UI组件往往是棘手，因为这其中涉及了许多移动部件。很多时候，视图控制器交互涉及很多来自模型层和视图层的类。为了能测试这些视图控制器。我们需要隔离东西去进行。</h4>

<h4>让你高兴地是，通过我们描述的使得<a href="http://javalipengfei.github.io/blog/2013/12/02/geng-qing-xiao-de-shi-tu-kong-zhi-qi-fan-yi-1/">使视图控制器变轻</a>的技术让测试变得更简单。一般来说。假如你发现一些非常难测试的地方。这就会暗示你设计的不是很合理，并且你需要重构它，再一次参考这篇文章<a href="http://javalipengfei.github.io/blog/2013/12/02/geng-qing-xiao-de-shi-tu-kong-zhi-qi-fan-yi-1/">使视图控制器变轻</a>对于那些不合理的设计。总体的设计目标是有一个清晰的关注点分离，每一个类应该只做一件事情，并且把这件事情做好。那么这是就会测试一件事情了。</h4>

<h3>记住:你增加越多的测试你得到的回报将会递减。首先增加简单的测试,从非常复杂的测试中分离出简单的测试，你会感觉到更舒服。</h3>

<h3>Mocking</h3>

<h4>当我们把事情拆分到很小的部分的时候。我们可以测试他拥有每一个类。我们测试这个类与其它类的交互。我们可以围绕这个类使用被称作mock 或者stub的测试方法。想像一个mock对象作为一个替换对象。我们测试这个类将会用替换对象代替真实对象进行交互。通过这个方法，我们可以致力于测试而且不用以来我们app的其他部分。</h4>

<h4>这个app的事例有一个我们测试的数组的数据源。这些数据将会在某一时刻出现在tableviw的cell上。在测试期间，我们没有tableivew。但是通过传第一个mock tableview，这样我们可以测试数据源在没有一个真实的tableview的时候。你会在下边看到。刚开始一点混乱。但是非常的好用和简单一旦你用它几次。</h4>

<h4>这最好的工具对于mocking 在Objective-c是被成为<a href="http://ocmock.org">OCMock</a>。这是一个非常成熟的项目，充分利用了Objective-C运行库的强大功能和灵活性。它把一些很酷的技巧，让通过mack 对象测试更有趣。</h4>

<h4>这数据源测试将在下边展示，更多的细节就是如何发挥这一切。</h4>

<h3>SenTestKit</h3>

<h4>这另外一个工具是我们将会使用的测试框架。这个框架作为开发者工具的一部分：ScenTestKit 来自<a href="http://www.sente.ch/">Sentn</a>.自1997年以来这个“恐龙“”已经存在了Objective-C的开发者 &ndash; 前十年的iPhone发布。如今，它的集成在Xcode中。</h4>

<h4>SenTestingKit 可以运行你的测试。通过SenTestKit，你会集成测试到你的类里面。你可以创建一个测试类为每一个你想测试的类。这个类将会有一个结尾名字在测试中。这个结尾名字会反映关于哪个类的测试。</h4>

<h4>在每一个测试类里面都有一个真实执行的测试类方法。这个测试方法名字必须一test开头作为触发器去运行这个test方法。有一个唯一的——setUP和-tearDown方法你可以重写在每一个测试类中。请记住，你的测试类只是一个类：它可以帮助你组织你的测试，可以自由地添加属性和helper方法。</h4>

<h4>一个漂亮的设计为测试创建一个漂亮的基类。我们放入一个合理的逻辑使我们的测试更简单更有效。导出<a href="https://github.com/objcio/issue-1-lighter-view-controllers/blob/master/PhotoDataTests/PhotoDataTestCase.h">事例工程</a>有一些简单的例子。我们不会用xcode模板去测试。我们的目标是简单高效，我们增加一个单独的.m文件。通过测试惯例有一个结尾名字。这个名字反映我们正在测试。</h4>

<h3>集成Xcode</h3>

<h4>测试内置到您选择的动态库以及资源包。假如你需要特别的测试资源针对你的测试。你需要将他们加入到测试的Target中，Xcode将会把他们放到资源包中。你可以取到他们通过NSBundle。这个事例工程实现了 -URLForResource:withExtension:的方法使它跟简单易用。</h4>

<h4>在Xcode中每一个scheme定义了相应的测试资源。⌘-R是运行APP，⌘-U是测试。测试如果已经运行，并且你的app已经启动。测试资源将会被干扰。测试运行的方式，您的应用程序实际上推出，而测试包注入。你可能不希望您的应用程序做太多，因为它可能与测试干扰。把下面的内容到你的应用程序委托：</h4>

<p>static BOOL isRunningTests(void) <strong>attribute</strong>((const));</p>

<ul>
<li><p>(BOOL)application:(UIApplication <em>)application <br/>
      didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions
{
  if (isRunningTests()) {
      return YES;
  }</p>

<p>  //
  // Normal logic goes here
  //</p>

<p>  return YES;
}</p></li>
</ul>


<p>static BOOL isRunningTests(void)
{</p>

<pre><code>NSDictionary* environment = [[NSProcessInfo processInfo] environment];
NSString* injectBundle = environment[@"XCInjectBundle"];
return [[injectBundle pathExtension] isEqualToString:@"octest"];
</code></pre>

<p>}</p>

<h4>编辑你的scheme为你的测试提供了很大的灵活性。你可以运行脚本在测试之前或者之后。你可以有多个测试资源。这对于大型项目非常有帮助。最重要的是，你可以打开和关闭单独的测试。这对于调试非常有用的测试——仅仅记得让他们恢复原状。也请记住，你可以在你的代码和测试用例设置断点和调试器会停在那里为执行测试。</h4>

<h3>下面就是代码实战了 我会在此一次博客中更新 敬请期待。。。。。。</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[清空TableView 的代码(翻译2)]]></title>
    <link href="http://javalipengfei.github.io/blog/2013/12/04/qing-kong-tableview-de-dai-ma-fan-yi-2/"/>
    <updated>2013-12-04T11:56:00+08:00</updated>
    <id>http://javalipengfei.github.io/blog/2013/12/04/qing-kong-tableview-de-dai-ma-fan-yi-2</id>
    <content type="html"><![CDATA[<h5>作者<a href="http://twitter.com/floriankugler">Florian Kugler</a></h5>

<h5>来源<a href="http://www.objc.io/issue-1/table-views.html">objc</a></h5>

<h4>tableView 对一个ios应用来说是一个多功能的组件。因此。一些代码直接的或间接的跟tableView的工作有关，比如说提供数据，更新tableView、控制他的行为和选中以及命名的反应，在这篇文章，<!--more-->我们将展现的技术是保持代码简洁和更好的代码结构。</h4>

<h3><center>UItableviewController VS. UIViewController </center></h3>

<h4>苹果提供了UItableViewController 作为tableVIews的专用ViewControler。UItableViewController 实现了很多能帮助我们避免重复一遍一遍的写样板代码的特性。在另一个方面，UItableViewController 被限制着管理一个铺满全屏的table view，然而，在很多案例中，这些是你需要的，如果他不是你需要的，有很多方法去解决这个问题，下面我门将会展示。</h4>

<h3><center>Table View Controllers 的特性</center></h3>

<h4>UItableVIewController 帮助你加在table view的数据当他第一次显示的时候。具体点。他帮助切换table view的编辑模式，反映键盘通知和一些小的特性象刷新scroll 的标识清空选中区域。为了这些特性能够工作，你要调用父类的视图事件方法（例如：viewWillAppear: and viewDidAppear:）在你的子类有可能被你重写的方法。</h4>

<h4>UItableViewController 有一个独特卖点就是在标准视图控制器之上。并且他支持苹果实现的滑动刷新功能。目前，这是唯一纪录的使用UIRefreshController 在tableVIewController里面。</h4>

<h4>苹果液晶定义了很多元素对于标准的table view的接口行为，如果你的app同意这些标准，它将是一个非常好的想法对于使用UItableViewController 避免写样板代码。</h4>

<h3><center>UItableViewControllers的限制</center></h3>

<h4>UITableViewController 的view必须设置为table view。如果你决定在你的屏幕的一边设置tableview，那你就尴尬了。</h4>

<h4>如果你已经定一个界面用.xib 文件，他将会非常简单转化为标准视图控制器，如果你用storyBoards，这时他会涉及到更多的步骤，通过sotryboards 你不能改变UItableViewController成为一个标准视图除非重新创建它。它意味着复制所有的内容到一个新的view controller并且再写一遍所有的东西。</h4>

<h4>最后 你需要添加你在转化中丢失的特性。大部分他们都是简单的单独一行状态在viewWillAppp或者viewDidAppear。切换编辑状态需要一个编辑tableview editting的属性的 action 方法，大部分工作在于重建键盘的支持。</h4>

<h4>在你按照这些方法做的时候，这有一个更简单的替代方案：分离关注点。</h4>

<h3><center>子视图控制器</center></h3>

<h4>相对于完全摆脱UItableViewController，你可以将UItableViewController作为子视图控制器加到别的视图控制器上。这时UItableViewController继续管理tableView 并且父视图可以管理你加在界面伤得任何你可能需要的视图。</h4>

<ul>
<li>(void)addPhotoDetailsTableView
{
  DetailsViewController *details = [[DetailsViewController alloc] init];
  details.photo = self.photo;
  details.delegate = self;
  [self addChildViewController:details];
  CGRect frame = self.view.bounds;
  frame.origin.y = 110;
  details.view.frame = frame;
  [self.view addSubview:details.view];  <br/>
  [details didMoveToParentViewController:self];
}

<h4>如果你用这个方式你必须建立一个通讯通道在子视图控制器和父试图控制器之间。例如，如果用户选择了一个cell在tableview，父视图控制器需要知道push另外的一个试图控制器，根据这个用例，常常使用代理协议的方式是最简洁的，你可以在父视图控制器实现这个协议。</h4></li>
</ul>


<p>@protocol DetailsViewControllerDelegate
&ndash; (void)didSelectPhotoAttributeWithKey:(NSString *)key;
@end</p>

<p>@interface PhotoViewController () <DetailsViewControllerDelegate>
@end</p>

<p>@implementation PhotoViewController
// &hellip;
&ndash; (void)didSelectPhotoAttributeWithKey:(NSString *)key
{</p>

<pre><code>DetailViewController *controller = [[DetailViewController alloc] init];
controller.key = key;
[self.navigationController pushViewController:controller animated:YES];
</code></pre>

<p>}
@end</p>

<h4>正如你所看见的，这个结构会带来一些开销对于试图控制器的通信换取关注点分离和更好的可重用性完全分离。从这个用例来看，它可以让事情变的更简单或者更复杂，这取决于你的考虑和决定</h4>

<h3><center> 分离关注点 </center></h3>

<h4>当表视图处理有很多种，涉及不同的任务，其中交叉模型，控制器和视图之间的边界。为了防止视图控制器成为所有这些任务的地方，我们会尝试找出尽可能多的任务，尽可能在更合适的地方。这有助于可读性，可维护性和可测试性。</h4>

<h4>这里描述的技术延伸和阐述后，在<a href="http://javalipengfei.github.io/blog/2013/12/02/geng-qing-xiao-de-shi-tu-kong-zhi-qi-fan-yi-1/">更轻小的视图控制器</a>演示的概念。请参考这篇文章如何因素我们的数据源和模型的逻辑。在表视图的背景下，我们将具体来看看如何视图控制器和视图之间分离关注点。</h4>

<h3><center>在cell和模型对象建立沟通桥梁</center></h3>

<h4>在某些时候，我们要交给我们想要显示到视图层的数据。由于我们仍然要保持模型和视图之间的明确分离，我们常常分离这个任务到tableview的数据源</h4>

<ul>
<li><p>(UITableViewCell * )tableView:(UITableView * )tableView
       cellForRowAtIndexPath:(NSIndexPath * )indexPath
{
  PhotoCell * cell = [tableView dequeueReusableCellWithIdentifier:@&ldquo;PhotoCell&rdquo;];</p>

<p>  Photo * photo = [self itemAtIndexPath:indexPath];
  cell.photoTitleLabel.text = photo.name;
  NSString* date = [self.dateFormatter stringFromDate:photo.creationDate];
  cell.photoDateLabel.text = date;
}</p>

<h4>我们可以将数据源中杂乱的代码设计一下，我们最好把它放到cell的分类中：</h4>

<p>@implementation PhotoCell (ConfigureForPhoto)</p></li>
<li><p>(void)configureForPhoto:(Photo * )photo
{
  self.photoTitleLabel.text = photo.name;
  NSString* date = [self.dateFormatter stringFromDate:photo.creationDate];
  self.photoDateLabel.text = date;
}</p></li>
</ul>


<p>@end</p>

<h4>我们数据源的代码会变的特别简洁</h4>

<ul>
<li>(UITableViewCell <em>)tableView:(UITableView </em>)tableView
       cellForRowAtIndexPath:(NSIndexPath <em>)indexPath
{
  PhotoCell </em>cell = [tableView dequeueReusableCellWithIdentifier:PhotoCellIdentifier];
  [cell configureForPhoto:[self itemAtIndexPath:indexPath]];
  return cell;
}</li>
</ul>


<h4>在我们的事例代码中table view的数据源<a href="http://javalipengfei.github.io/blog/2013/12/02/geng-qing-xiao-de-shi-tu-kong-zhi-qi-fan-yi-1/">是分离出我们控制器对象的</a>，我们初始化一个配置cell的方法块。用这种方式，这个方法快变的更简单：</h4>

<p>TableViewCellConfigureBlock block = ^(PhotoCell <em>cell, Photo </em>photo) {</p>

<pre><code>[cell configureForPhoto:photo];
</code></pre>

<p>};</p>

<h3><center>cell重用</center></h3>

<h4>在这个例子中，我们将介绍多种对象类型使用同一个cell类型，我们甚至可以更进一步增加cell的重用性。首先，我们定义一个使这个对象必须符合这个这个cell的类型的才能显示到cell的协议。这时我们简单的改变cell类中的配置方法来显示任何符合协议的cell。这些简单的步骤让cell从任何特定的模型对象种分离出来并且使他应用到不同的数据模型。</h4>

<h3><center>在cell类别种处理cell状态</center></h3>

<h4>假如我们想做一些额外的事情对于标准的变灰或者选中行为的，我们可以实现两个代理方法，他会改变点击cell的效果变成我们想要的。例如：</h4>

<ul>
<li><p>(void)tableView:(UITableView <em>)tableView
      didHighlightRowAtIndexPath:(NSIndexPath </em>)indexPath
{
  PhotoCell *cell = [tableView cellForRowAtIndexPath:indexPath];
  cell.photoTitleLabel.shadowColor = [UIColor darkGrayColor];
  cell.photoTitleLabel.shadowOffset = CGSizeMake(3, 3);
}</p></li>
<li><p>(void)tableView:(UITableView <em>)tableView
      didUnhighlightRowAtIndexPath:(NSIndexPath </em>)indexPath
{
  PhotoCell *cell = [tableView cellForRowAtIndexPath:indexPath];
  cell.photoTitleLabel.shadowColor = nil;
}</p></li>
</ul>


<h4>然而，这两个委托方法的实现又依赖于对cell是如何实现的具体知识。如果我们想换出cell或重新设计它以不同的方式，我们也要有适应的委托代码。这个实现的细节被完成通过实现这个代理方法。相反，我们应该把这个逻辑进入cell本身。</h4>

<p>@implementation PhotoCell
// &hellip;
&ndash; (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated
{</p>

<pre><code>[super setHighlighted:highlighted animated:animated];
if (highlighted) {
    self.photoTitleLabel.shadowColor = [UIColor darkGrayColor];
    self.photoTitleLabel.shadowOffset = CGSizeMake(3, 3);
} else {
    self.photoTitleLabel.shadowColor = nil;
}
</code></pre>

<p>}
@end</p>

<h4>一般来说，我们努力分离视图层的详细实现从控制层，代理必须知道一个视图的不同状态，但是他可以不知道关于如何改变视图树或者如何获取一些子视图的的正确属性。所有的逻辑应该封装到视图里面，对外只需要提供一个简单的接口。</h4>

<h3><center>处理多变的cell类型</center></h3>

<h4>如果你有不同的cell类型在tableView，这数据源的方法很快会失控。在我们的用例应用种我们有两个不同类型，一个用来显示星级的、一个用来显示键值对的。为了分离代码处理这些cell类型，数据源方法简单的分离了专门方法的请求对于不同的cell类型。</h4>

<ul>
<li><p>(UITableViewCell <em>)tableView:(UITableView </em>)tableView<br/>
       cellForRowAtIndexPath:(NSIndexPath <em>)indexPath
{
  NSString </em>key = self.keys[(NSUInteger) indexPath.row];
  id value = [self.photo valueForKey:key];
  UITableViewCell *cell;
  if ([key isEqual:PhotoRatingKey]) {
      cell = [self cellForRating:value indexPath:indexPath];
  } else {
      cell = [self detailCellForKey:key value:value];
  }
  return cell;
}</p></li>
<li><p>(RatingCell <em>)cellForRating:(NSNumber </em>)rating
                  indexPath:(NSIndexPath *)indexPath
{
  // &hellip;
}</p></li>
<li><p>(UITableViewCell <em>)detailCellForKey:(NSString </em>)key
                              value:(id)value
{
  // &hellip;
}</p></li>
</ul>


<h3><center>表格编辑</center></h3>

<h4>tableview提供了简单易用的编辑特性，允许简单的重新排序和删除cell。这这些事件中，tableview的数据源得到了代理方法的通知，因此 我们常常看到主要的逻辑在这些代理方法中去改数据。</h4>

<h4>更改数据很明显使模型层的任务。模型层应该提供例如重新排序和删除的接口以便于我们可以从数据源方法调用。通过这种方法，这个控制层充当视图和模型的协调的角色，不用去知道模型层的详细实现细节。还有一个好处，这个模型层的逻辑也变的简单测试，因为他不会与其他试图控制器有交织。</h4>

<h3><center>总结</center></h3>

<h4>TableVIewController（或者其他控制器对象）大部分使扮演一个交流和调节的角色在模型对象和试图对象之间，如果你坚持这个思想，代理和数据源方法将会变的更小并且包含更简单的模版代码.</h4>

<h4>这么做不仅仅使减少了大小和降低了TableViewController的复杂性。而且他使得主要的逻辑和视图逻辑等多了放到了合适的地方。上边和下边的控制层实现细节都封装到了一个简单的接口中，它最终使理解代码和他们之间合作变的更简单。</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[更轻小的视图控制器(翻译1)]]></title>
    <link href="http://javalipengfei.github.io/blog/2013/12/02/geng-qing-xiao-de-shi-tu-kong-zhi-qi-fan-yi-1/"/>
    <updated>2013-12-02T17:24:00+08:00</updated>
    <id>http://javalipengfei.github.io/blog/2013/12/02/geng-qing-xiao-de-shi-tu-kong-zhi-qi-fan-yi-1</id>
    <content type="html"><![CDATA[<h4>作者 <a href="http://twitter.com/chriseidhof">Chris Eidhof</a></h4>

<h4><a href="http://www.objc.io/issue-1/lighter-view-controllers.html">原文</a></h4>

<h4>视图控制器常常是IOS工程中最大的文件，并且它包含了一些以不必要方式存在的代码。通常，视图控制器是代码重用最少的部分。我们寻找使试图控制器变小变轻的技术，使代码提高重用，移动代码到更合适的地方。</h4>

<h4>这是一个托管在github的一个<a href="https://github.com/objcio/issue-1-lighter-view-controllers">例子</a></h4>

<h3><center>分离数据源和其他的协议</center></h3>

<!-- more -->


<h4>让视图控制器变的更轻的最好的技术就是将UITableViewDataSource的部分从你的代码中移动到自己的类中。假如你曾经一次这么做过，你将会看到模式和创建一个可以重用的类。</h4>

<h3>例如 在我们的事例工程中，有一个PhotosViewController有如下的方法</h3>

<p> pragma mark Pragma</p>

<ul>
<li><p>(Photo<em>)photoAtIndexPath:(NSIndexPath</em>)indexPath {
  return photos[(NSUInteger)indexPath.row];
}</p></li>
<li><p>(NSInteger)tableView:(UITableView*)tableView
numberOfRowsInSection:(NSInteger)section {
  return photos.count;
}</p></li>
<li><p>(UITableViewCell<em>)tableView:(UITableView</em>)tableView
      cellForRowAtIndexPath:(NSIndexPath<em>)indexPath {
  PhotoCell</em> cell = [tableView dequeueReusableCellWithIdentifier:PhotoCellIdentifier
                                                    forIndexPath:indexPath];
  Photo* photo = [self photoAtIndexPath:indexPath];
  cell.label.text = photo.name;
  return cell;
}</p>

<h4>这些代码通过数组做了一些事情。他们当中的具体的photos是被视图控制器管理的。所以让我们尝试移动与数组相关的代码到我们自己的类中。我们用一个方法块配置cell ，也可以用代理去做。根据的你的用例去选择和尝试。</h4>

<p>@implementation ArrayDataSource</p></li>
<li><p>(id)itemAtIndexPath:(NSIndexPath*)indexPath {
  return items[(NSUInteger)indexPath.row];
}</p></li>
<li><p>(NSInteger)tableView:(UITableView*)tableView
numberOfRowsInSection:(NSInteger)section {
  return items.count;
}</p></li>
<li><p>(UITableViewCell<em>)tableView:(UITableView</em>)tableView
      cellForRowAtIndexPath:(NSIndexPath*)indexPath {
  id cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier
                                            forIndexPath:indexPath];
  id item = [self itemAtIndexPath:indexPath];
  configureCellBlock(cell,item);
  return cell;
}</p></li>
</ul>


<p>@end</p>

<h4>这三个方法在你的视图控制器中可以运行 并且代替ni场jain的的一个对象并且设置他的数据源。</h4>

<p>void (^configureCell)(PhotoCell<em>, Photo</em>) = ^(PhotoCell<em> cell, Photo</em> photo) {
   cell.label.text = photo.name;
};
photosArrayDataSource = [[ArrayDataSource alloc] initWithItems:photos</p>

<pre><code>                                            cellIdentifier:PhotoCellIdentifier
                                        configureCellBlock:configureCell];
</code></pre>

<p>self.tableView.dataSource = photosArrayDataSource;</p>

<h4>现在你不用不得不担心关于便利数组位置的索引。并且无论何时你想在tableview中展是一个数组你都可以重用这段代码。你也可以实现额外的方法。例如</h4>

<p>tableView:commitEditingStyle:forRowAtIndexPath: 并且分享代码到你所有的table view controllers.</p>

<h4>这是一个非常漂亮的<a href="http://www.objc.io/issue-1/testing-view-controllers.html#testing-datasource">分离测试例子</a> 并且再也不用担心重写它了。</h4>

<h4>在今年工作中编写的apps中，我们着重使用了核心数据。我们创建了一个简单的类代替依靠数组的牵强结果的控制器。它实现了所有的更新动画。头部内容和删除的逻辑，你可以创建这个对象的一个实例并且给他一个读写请求和一个方法快配置cell。剩下的自己就会运行。</h4>

<h4>未来，这同样可以扩展协议的途径。一个明显的候选例子是UICollectionViewDataSource。这给了你极大的灵活性，如果，在开发过程中某一时刻，你决定要一个UICollectionView，而不是一个UITableView，你几乎不必在你的视图控制器改变任何东西。你甚至可以让你的数据源支持两种协议。</h4>

<h3><center>移动主要逻辑到Model中去</center></h3>

<h4>这是一个视图控制器中支持找到user类归档属性的代码</h4>

<ul>
<li>(void)loadPriorities {
NSDate<em> now = [NSDate date];
NSString</em> formatString = @&ldquo;startDate &lt;= %@ AND endDate >= %@&rdquo;;
NSPredicate<em> predicate = [NSPredicate predicateWithFormat:formatString, now, now];
NSSet</em> priorities = [self.user.priorities filteredSetUsingPredicate:predicate];
self.priorities = [priorities allObjects];
}

<h4>无论无何，将这些代码移到user类的分类中去，它会变的更轻。象下面这个视图控制器的代码：</h4></li>
<li>(void)loadPriorities {
self.priorities = [user currentPriorities];
}

<h4>User+Extensions.m:</h4></li>
<li>(NSArray<em>)currentPriorities {
NSDate</em> now = [NSDate date];
NSString<em> formatString = @&ldquo;startDate &lt;= %@ AND endDate >= %@&rdquo;;
NSPredicate</em> predicate = [NSPredicate predicateWithFormat:formatString, now, now];
return [[self.priorities filteredSetUsingPredicate:predicate] allObjects];
}</li>
</ul>


<h4>一些代码不能被简单的移到model对象中 但是它仍然可以变的更轻通过相关的model代码。例如：</h4>

<h3><center>创建一个存储类 </center></h3>

<h4>在第一个版本的例子中，我们有一些加载数据从文件中并且解析它的代码。在视图控制器的代码：</h4>

<ul>
<li>(void)readArchive {
  NSBundle<em> bundle = [NSBundle bundleForClass:[self class]];
  NSURL </em>archiveURL = [bundle URLForResource:@&ldquo;photodata&rdquo;
                               withExtension:@&ldquo;bin&rdquo;];
  NSAssert(archiveURL != nil, @&ldquo;Unable to find archive in bundle.&rdquo;);
  NSData <em>data = [NSData dataWithContentsOfURL:archiveURL
                                       options:0
                                         error:NULL];
  NSKeyedUnarchiver </em>unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];
  <em>users = [unarchiver decodeObjectOfClass:[NSArray class] forKey:@&ldquo;users&rdquo;];
  </em>photos = [unarchiver decodeObjectOfClass:[NSArray class] forKey:@&ldquo;photos&rdquo;];
  [unarchiver finishDecoding];
}

<h4>视图控制器不必知道他是如何运转的。我们创建一个存储对象。通过分离他我们可以重用它，测试分离让我们的视图控制器更小。这个类可以实现数据加载，缓存，设置数据堆，这个类常常被成为服务层。</h4>

<h3><center>将网页服务的逻辑放到模型层</center></h3>

<h4>这个跟上边的是一样的话题：不要将网页服务逻辑放到视图控制器中，相反，分开到不同的类中，你的视图控制器可以掉调用方法通过回调处理，这是一个非常好的事情对于你处理所有的异常和错误</h4>

<h3><center> 通讯</cetner></h3>

<h4>另一件在视图控制器中经常发生的事情是与其他视图控制器，模型，和视图通信。这是一个视图控制器应该做的，他也是我们要实现的通过最少的代码。</h4>

<h4>有很多好的扩展技术在视图和模型对象中通信（例如KVO 和）无论怎样 视图通信常常是很小的一部分 我们经常遇到的问题一个视图有很多状态并且与相关的其他视图控制器相关。常常  设置一个状态到一个分离的对象中并且传递他通过视图控制器，则是所有的对象都会改变状态。他的优势是它是唯一一个再一个地方 并且我们不用纠结他的回调对象的调用。</h4>

<h3><center>总结</center></h3>

<h4>我们已经看到了创建更小视图控制器的技术。我们不追求尽可能的应用这些技术，因为我们只有一个目标：编写可维护的代码。通过了解这些模式，我们有选择更轻的视图控制器，使他们更清楚更好。</h4></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios开发 AudioToolBox框架音频播放的点滴(2)]]></title>
    <link href="http://javalipengfei.github.io/blog/2013/10/28/ioskai-fa-audiotoolboxkuang-jia-yin-pin-bo-fang-de-dian-di-2/"/>
    <updated>2013-10-28T17:57:00+08:00</updated>
    <id>http://javalipengfei.github.io/blog/2013/10/28/ioskai-fa-audiotoolboxkuang-jia-yin-pin-bo-fang-de-dian-di-2</id>
    <content type="html"><![CDATA[<h2>今天继续研究AudioToolBox的播放功能。</h2>

<h3>设置流的大小和读取包的个数</h3>

<!--more-->


<p>UInt32 maxPacketSize;</p>

<p>UInt32 propertySize = sizeof (maxPacketSize);</p>

<p>AudioFileGetProperty (                               // 1</p>

<pre><code>aqData.mAudioFile,                               // 2
kAudioFilePropertyPacketSizeUpperBound,          // 3
&amp;propertySize,                                   // 4
&amp;maxPacketSize                                   // 5
</code></pre>

<p>);</p>

<p>DeriveBufferSize (                                   // 6</p>

<pre><code>aqData.mDataFormat,                              // 7
maxPacketSize,                                   // 8
0.5,                                             // 9
&amp;aqData.bufferByteSize,                          // 10
&amp;aqData.mNumPacketsToRead                        // 11
</code></pre>

<p>);</p>

<ol>
<li>通过AudioFileGetProperty方法获取读取包的个数的最大值(大约)</li>
<li>音频文件引用</li>
<li>通过这个参数可以计算出最大的包数</li>
<li>这个kAudioFilePropertyPacketSizeUpperBound属性的字节的大小</li>
<li>你想播放的包的大小</li>
<li>设置流的大小和读取包的数量</li>
<li>你要播放数据的音频播放格式</li>
<li>前面估计的包的最大值</li>
<li>每个音频应该持有的秒数。</li>
<li> 设置读取流的字节数</li>
<li> 设置读取包的个数

<h3>为包中的数据结构开辟空间</h3></li>
</ol>


<p>bool isFormatVBR = (                                       // 1</p>

<pre><code>aqData.mDataFormat.mBytesPerPacket == 0 ||
aqData.mDataFormat.mFramesPerPacket == 0
</code></pre>

<p>);</p>

<p>if (isFormatVBR) {                                         // 2</p>

<pre><code>aqData.mPacketDescs =
  (AudioStreamPacketDescription*) malloc (
    aqData.mNumPacketsToRead * sizeof (AudioStreamPacketDescription)
  );
</code></pre>

<p>} else {                                                   // 3</p>

<pre><code>aqData.mPacketDescs = NULL;
</code></pre>

<p>}</p>

<ol>
<li>判断音频格式是VBR的合适CBR的</li>
<li>如果是VBR格式的，通过前面得到读取包的数量计算开辟空间的大小</li>
<li>对于CBR格式的不需要包的数据描述</li>
</ol>


<h3>设置Magic Cookie(不知道怎么翻译,其实是一种特殊音频格式)</h3>

<p>UInt32 cookieSize = sizeof (UInt32);                   // 1
bool couldNotGetProperty =                             // 2</p>

<pre><code>AudioFileGetPropertyInfo (                         // 3
    aqData.mAudioFile,                             // 4
    kAudioFilePropertyMagicCookieData,             // 5
    &amp;cookieSize,                                   // 6
    NULL                                           // 7
);
</code></pre>

<p>if (!couldNotGetProperty &amp;&amp; cookieSize) {              // 8</p>

<pre><code>char* magicCookie =
    (char *) malloc (cookieSize);
AudioFileGetProperty (                             // 9
    aqData.mAudioFile,                             // 10
    kAudioFilePropertyMagicCookieData,             // 11
    &amp;cookieSize,                                   // 12
    magicCookie                                    // 13
);
AudioQueueSetProperty (                            // 14
    aqData.mQueue,                                 // 15
    kAudioQueueProperty_MagicCookie,               // 16
    magicCookie,                                   // 17
    cookieSize                                     // 18
);
free (magicCookie);                                // 19
</code></pre>

<p>}
1. 初始化
2. 判断时候存在Magic Cookies
3. 获取Cookies
4. 参数不用说了
5. 。。。。
6. 。。。。
7. 。。。
8. 是否存在Magic cookies
9. 开辟空间
10. 音频文件
11. 参数。。。。
12. 。。。。
13. 。。。。。
14. 设置Magic Cookies
。。。。。。。</p>

<h3>为音频队列流开辟空间并且初始化</h3>

<p>aqData.mCurrentPacket = 0;                                // 1</p>

<p>for (int i = 0; i &lt; kNumberBuffers; ++i) {                // 2</p>

<pre><code>AudioQueueAllocateBuffer (                            // 3
    aqData.mQueue,                                    // 4
    aqData.bufferByteSize,                            // 5
    &amp;aqData.mBuffers[i]                               // 6
); 
HandleOutputBuffer (                                  // 7
    &amp;aqData,                                          // 8
    aqData.mQueue,                                    // 9
    aqData.mBuffers[i]                                // 10
);
</code></pre>

<p>}
2. 开辟3个音频流的空间
3. 开空间
4. 音频队列
5. 音频流的大小
6. 存储的音频流
7. 填充流到音频对列中
8. 客户端对象
9. 音频队列
10. 音频队列流</p>

<h3>设置音频队列的增益 这里是设置音量的增益</h3>

<p>Float32 gain = 1.0;                                       // 1</p>

<pre><code>// Optionally, allow user to override gain setting here
</code></pre>

<p>AudioQueueSetParameter (                                  // 2</p>

<pre><code>aqData.mQueue,                                        // 3
kAudioQueueParam_Volume,                              // 4
gain                                                  // 5
</code></pre>

<p>);</p>

<ol>
<li>初始化 范围是0—1</li>
<li>设置参数</li>
<li>音频队列</li>
<li>声音参数</li>
<li>增益参数</li>
</ol>


<h3>开始播放音频队列</h3>

<p>aqData.mIsRunning = true;                          // 1</p>

<p>AudioQueueStart (                                  // 2</p>

<pre><code>aqData.mQueue,                                 // 3
NULL                                           // 4
</code></pre>

<p>);</p>

<p>do {                                               // 5</p>

<pre><code>CFRunLoopRunInMode (                           // 6
    kCFRunLoopDefaultMode,                     // 7
    0.25,                                      // 8
    false                                      // 9
);
</code></pre>

<p>} while (aqData.mIsRunning);</p>

<p>CFRunLoopRunInMode (                               // 10</p>

<pre><code>kCFRunLoopDefaultMode,
1,
false
</code></pre>

<p>);</p>

<ol>
<li>是否停止播放的标志</li>
<li>开始音频队列的播放</li>
<li>音频队列</li>
<li>。。。</li>
<li>以后使我的下一个研究的对象</li>
</ol>


<h3>清空队列 释放空间</h3>

<p>AudioQueueDispose (                            // 1</p>

<pre><code>aqData.mQueue,                             // 2
true                                       // 3
</code></pre>

<p>);</p>

<p>AudioFileClose (aqData.mAudioFile);            // 4</p>

<p>free (aqData.mPacketDescs);</p>

<h2>至此 可以播放出来声音了 但是还是会有很多问题 后面我会慢慢去优化它。</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ios开发 AudioToolBox框架音频播放的点滴]]></title>
    <link href="http://javalipengfei.github.io/blog/2013/10/23/ioskai-fa-audiotoolboxkuang-jia-yin-pin-bo-fang-de-dian-di/"/>
    <updated>2013-10-23T17:24:00+08:00</updated>
    <id>http://javalipengfei.github.io/blog/2013/10/23/ioskai-fa-audiotoolboxkuang-jia-yin-pin-bo-fang-de-dian-di</id>
    <content type="html"><![CDATA[<blockquote><h4>今天研究了一下AudioToolBox苹果的音频开发框架。在我的不懈坚持下，终于可以放出声来了。但是仅仅是能放出声，对于一个追求强大的程序员来说这只是一个开始，虽然艰难，但是开始了 哈哈，<!--more-->下面呈上我对AudioToolBox播放音频的理解。</h4>

<h4>首先写代码之前要先了解流程才能事半功倍，下面是我用我的英语(你懂的)翻译的苹果官方网站的一些资料</h4>

<ol>
<li>首先定一个客户端机构体去管理状态，格式和路径等信息</li>
<li>写一个音频队列方法去执行音频的播放</li>
<li>写一个方法去计算音频队列流的大小</li>
<li>创建一个音频队列并且配置播放</li>
<li>为音频队列流开空间并且加入到队列，告诉音频队列开始播放，当做完这些，播放方法会调用回调方法这个音频队列播放完毕。</li>
<li>清除音频队列，并且释放资源。</li>
</ol>
</blockquote>

<h4>大概流程就这样的 我们只要按照这个流程去做就可以播放出美妙的音乐了 。我们来一一接受流程的步骤</h4>

<p> <!-- more —--></p>

<h2>首先介绍客户端结构的的数据结构</h2>

<p>struct AQPlayerState {</p>

<pre><code>AudioStreamBasicDescription  mDataFormat;                    // 1

AudioQueueRef                 mQueue;                         // 2

AudioQueueBufferRef           mBuffers[kNumberBuffers];       // 3

AudioFileID                   mAudioFile;                     // 4

UInt32                        bufferByteSize;                 // 5

SInt64                        mCurrentPacket;                 // 6

UInt32                        mNumPacketsToRead;              // 7

AudioStreamPacketDescription  *mPacketDescs;                  // 8

bool                          mIsRunning;                     // 9
</code></pre>

<p>};</p>

<ol>
<li>对音频流基本信息的描述(包含比特率，帧之类的信息，是音乐流中的含有的数据，你会通过方法获得其中的数据) 是一个结构体</li>
<li>音频队列</li>
<li>音频队列流</li>
<li>音频文件</li>
<li>音频队列中字节数的大小</li>
<li>包的索引值 意味着下一个包将会用于播放</li>
<li>读取的包的数量</li>
<li>音频流中包的基本信息的描述 也是一个结构体</li>
<li>判断当前的音频队列是否还在播放

<h4>这个结构体主要存储一些播放用的状态，数据格式等。</h4></li>
</ol>


<h2>写一个音频队列方法去执行音频的播放（这是一个回调方法）</h2>

<p>static void HandleOutputBuffer (</p>

<pre><code>void                 *aqData,                 // 1
AudioQueueRef        inAQ,                    // 2
AudioQueueBufferRef  inBuffer                 // 3
</code></pre>

<p>)</p>

<ol>
<li>上面创建的客户端机构体</li>
<li>音频队列</li>
<li>音频流</li>
</ol>


<h4>用于读取包中的数据到音频队列流中 在将音频队列流加入到音频队列中 AudioQueue一旦填满队列就会自动播放当播放完一个流的时候播放下一个音频流，当前流队列会推出来并且被填满数据。下面是具体实现方法：</h4>

<p>static void HandleOutputBuffer (</p>

<pre><code>void                *aqData,
AudioQueueRef       inAQ,
AudioQueueBufferRef inBuffer
</code></pre>

<p>) {</p>

<pre><code>AQPlayerState *pAqData = (AQPlayerState *) aqData;        // 1
if (pAqData-&gt;mIsRunning == 0) return;                     // 2
UInt32 numBytesReadFromFile;                              // 3
UInt32 numPackets = pAqData-&gt;mNumPacketsToRead;           // 4
AudioFileReadPackets (
    pAqData-&gt;mAudioFile,
    false,
    &amp;numBytesReadFromFile,
    pAqData-&gt;mPacketDescs, 
    pAqData-&gt;mCurrentPacket,
    &amp;numPackets,
    inBuffer-&gt;mAudioData 
);
if (numPackets &gt; 0) {                                     // 5
    inBuffer-&gt;mAudioDataByteSize = numBytesReadFromFile;  // 6
   AudioQueueEnqueueBuffer ( 
        pAqData-&gt;mQueue,
        inBuffer,
        (pAqData-&gt;mPacketDescs ? numPackets : 0),
        pAqData-&gt;mPacketDescs
    );
    pAqData-&gt;mCurrentPacket += numPackets;                // 7 
} else {
    AudioQueueStop (
        pAqData-&gt;mQueue,
        false
    );
    pAqData-&gt;mIsRunning = false; 
}
</code></pre>

<p>}</p>

<ol>
<li>客户端结构体 前面提到的。</li>
<li>检测队列是否还在播放</li>
<li>读取的字节的数量从文件中</li>
<li>读取的包</li>
<li>假如读取的包大于0 说明还有音频 要添加到音频队列中</li>
<li>设置读取的字节数量的大小</li>
<li>设置当前读取的报的位置</li>
</ol>


<h2>写一个方法去计算音频队列流的大小</h2>

<p>void DeriveBufferSize (</p>

<pre><code>AudioStreamBasicDescription ASBDesc,                            // 1
UInt32                      maxPacketSize,                       // 2
Float64                     seconds,                             // 3
UInt32                      *outBufferSize,                      // 4
UInt32                      *outNumPacketsToRead                 // 5
</code></pre>

<p>) {</p>

<pre><code>static const int maxBufferSize = 0x50000;                        // 6
static const int minBufferSize = 0x4000;                         // 7

if (ASBDesc.mFramesPerPacket != 0) {                             // 8
    Float64 numPacketsForTime =
        ASBDesc.mSampleRate / ASBDesc.mFramesPerPacket * seconds;
    *outBufferSize = numPacketsForTime * maxPacketSize;
} else {                                                         // 9
    *outBufferSize =
        maxBufferSize &gt; maxPacketSize ?
            maxBufferSize : maxPacketSize;
}

if (                                                             // 10
    *outBufferSize &gt; maxBufferSize &amp;&amp;
    *outBufferSize &gt; maxPacketSize
)
    *outBufferSize = maxBufferSize;
else {                                                           // 11
    if (*outBufferSize &lt; minBufferSize)
        *outBufferSize = minBufferSize;
}

*outNumPacketsToRead = *outBufferSize / maxPacketSize;           // 12
</code></pre>

<p>}</p>

<ol>
<li>音频流的数据描述结构 就是我们定义的那个客户端的mDataFormat</li>
<li><p>最大包的数量 可以根据UInt32 maxPacketSize;
UInt32 propertySize = sizeof (maxPacketSize);
AudioFileGetProperty (                               // 1</p>

<p>  aqData.mAudioFile,                               // 2</p>

<p>  kAudioFilePropertyPacketSizeUpperBound,          // 3</p>

<p>  &amp;propertySize,                                   // 4</p>

<p>  &amp;maxPacketSize                                   // 5
);这个方法获得大约的最大值(这里不用读取全部数据就可以得到最大的报数的大约值)</p></li>
<li>一个音频队列流持有的时间。0.5秒是一个不错的选择</li>
<li>读取的一个音频队列流的大小</li>
<li>读取的一个音频队列包的数量</li>
</ol>


<h2>创建一个音频队列并且配置播放</h2>

<h4>打开一个音频文件</h4>

<p>AQPlayerState aqData;                                   // 1</p>

<p>OSStatus result =</p>

<pre><code>AudioFileOpenURL (                                  // 2
    audioFileURL,                                   // 3
    fsRdPerm,                                       // 4
    0,                                              // 5
    &amp;aqData.mAudioFile                              // 6
);
</code></pre>

<p>CFRelease (audioFileURL);                               // 7</p>

<ol>
<li>创建一个客户端数据结构体存储音频数据</li>
<li>打开一个音频文件</li>
<li>音频文件的url（可以用(CFURLRef)url）方式传入</li>
<li>获得读取音频文件的的权限</li>
<li>文件类型提示 不知道可以直接传入0</li>
<li>客户端结构体中音乐文件的引用</li>
</ol>


<h4>获得音频流中的数据结构描述</h4>

<p>UInt32 dataFormatSize = sizeof (aqData.mDataFormat);    // 1</p>

<p>AudioFileGetProperty (                                  // 2</p>

<pre><code>aqData.mAudioFile,                                  // 3
kAudioFilePropertyDataFormat,                       // 4
&amp;dataFormatSize,                                    // 5
&amp;aqData.mDataFormat                                 // 6
</code></pre>

<p>);</p>

<h6>参数很简单 一目了然</h6>

<h4>创建音频播放队列</h4>

<p>AudioQueueNewOutput (</p>

<pre><code>&amp;aqData.mDataFormat,                             // 1    
HandleOutputBuffer,                              // 2
&amp;aqData,                                         // 3
CFRunLoopGetCurrent (),                          // 4
kCFRunLoopCommonModes,                           // 5
0,                                               // 6
&amp;aqData.mQueue                                   // 7
</code></pre>

<p>);</p>

<ol>
<li>音频流的数据描述</li>
<li>填充并播放流到队列的回调方法</li>
<li>客户端数据</li>
<li>当前线程</li>
<li>一般运行模式</li>
<li>必须设置为0 相当于初始化</li>
<li>将队列交给客户端结构体中的队列

<h1>今天先写到这 明天更精彩 吼吼</h1></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[美好的开始]]></title>
    <link href="http://javalipengfei.github.io/blog/2013/10/17/mei-hao-de-kai-shi/"/>
    <updated>2013-10-17T16:14:00+08:00</updated>
    <id>http://javalipengfei.github.io/blog/2013/10/17/mei-hao-de-kai-shi</id>
    <content type="html"><![CDATA[<blockquote><h4>历尽各种磨难，查阅了无数资料，终于把这个博客搭建起来了。仰天长啸中。。。。。。 哈哈。。。。。。</h4>

<h4>为什么要建立这个博客呢：<!--more--></h4>

<ol>
<li>我觉得建立一个博客，可以督导我每天都写一点东西，来记录生活、工作、学习，一个自己的生活纪录片.</li>
<li>通过它可以分享一下我学到的、感悟到的东西给这个世界，让世界听到我的声音</li>
<li>人非圣贤 孰能无过，有时候学到的感悟到不一定就是正确的，在这里可以与不同的声音进行交流、提高、成长。</li>
<li>。。。。。</li>
</ol>
</blockquote>

<h4>总之博客的好处让你无法拒绝它。最后感谢开源给我们带来的美好生活。启程喽。。。。。。</h4>
]]></content>
  </entry>
  
</feed>

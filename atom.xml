<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[漫步云端]]></title>
  <link href="http://javalipengfei.github.io/atom.xml" rel="self"/>
  <link href="http://javalipengfei.github.io/"/>
  <updated>2013-12-02T18:57:02+08:00</updated>
  <id>http://javalipengfei.github.io/</id>
  <author>
    <name><![CDATA[李鹏飞]]></name>
    <email><![CDATA[javalipengfei@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[更轻小的视图控制器(翻译1)]]></title>
    <link href="http://javalipengfei.github.io/blog/2013/12/02/geng-qing-xiao-de-shi-tu-kong-zhi-qi-fan-yi-1/"/>
    <updated>2013-12-02T17:24:00+08:00</updated>
    <id>http://javalipengfei.github.io/blog/2013/12/02/geng-qing-xiao-de-shi-tu-kong-zhi-qi-fan-yi-1</id>
    <content type="html"><![CDATA[<h4>作者 <a href="http://twitter.com/chriseidhof">Chris Eidhof</a></h4>

<h4><a href="http://www.objc.io/issue-1/lighter-view-controllers.html">原文</a></h4>

<h4>视图控制器常常是IOS工程中最大的文件，并且它包含了一些以不必要方式存在的代码。通常，视图控制器是代码重用最少的部分。我们寻找使试图控制器变小变轻的技术，使代码提高重用，移动代码到更合适的地方。</h4>

<h4>这是一个托管在github的一个<a href="https://github.com/objcio/issue-1-lighter-view-controllers">例子</a></h4>

<h3><center>分离数据源和其他的协议</center></h3>

<!-- more -->


<h4>让视图控制器变的更轻的最好的技术就是将UITableViewDataSource的部分从你的代码中移动到自己的类中。假如你曾经一次这么做过，你将会看到模式和创建一个可以重用的类。</h4>

<h3>例如 在我们的事例工程中，有一个PhotosViewController有如下的方法</h3>

<p> pragma mark Pragma</p>

<ul>
<li><p>(Photo<em>)photoAtIndexPath:(NSIndexPath</em>)indexPath {
  return photos[(NSUInteger)indexPath.row];
}</p></li>
<li><p>(NSInteger)tableView:(UITableView*)tableView
numberOfRowsInSection:(NSInteger)section {
  return photos.count;
}</p></li>
<li><p>(UITableViewCell<em>)tableView:(UITableView</em>)tableView
      cellForRowAtIndexPath:(NSIndexPath<em>)indexPath {
  PhotoCell</em> cell = [tableView dequeueReusableCellWithIdentifier:PhotoCellIdentifier
                                                    forIndexPath:indexPath];
  Photo* photo = [self photoAtIndexPath:indexPath];
  cell.label.text = photo.name;
  return cell;
}</p>

<h4>这些代码通过数组做了一些事情。他们当中的具体的photos是被视图控制器管理的。所以让我们尝试移动与数组相关的代码到我们自己的类中。我们用一个方法块配置cell ，也可以用代理去做。根据的你的用例去选择和尝试。</h4>

<p>@implementation ArrayDataSource</p></li>
<li><p>(id)itemAtIndexPath:(NSIndexPath*)indexPath {
  return items[(NSUInteger)indexPath.row];
}</p></li>
<li><p>(NSInteger)tableView:(UITableView*)tableView
numberOfRowsInSection:(NSInteger)section {
  return items.count;
}</p></li>
<li><p>(UITableViewCell<em>)tableView:(UITableView</em>)tableView
      cellForRowAtIndexPath:(NSIndexPath*)indexPath {
  id cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier
                                            forIndexPath:indexPath];
  id item = [self itemAtIndexPath:indexPath];
  configureCellBlock(cell,item);
  return cell;
}</p></li>
</ul>


<p>@end</p>

<h4>这三个方法在你的视图控制器中可以运行 并且代替ni场jain的的一个对象并且设置他的数据源。</h4>

<p>void (^configureCell)(PhotoCell<em>, Photo</em>) = ^(PhotoCell<em> cell, Photo</em> photo) {
   cell.label.text = photo.name;
};
photosArrayDataSource = [[ArrayDataSource alloc] initWithItems:photos</p>

<pre><code>                                            cellIdentifier:PhotoCellIdentifier
                                        configureCellBlock:configureCell];
</code></pre>

<p>self.tableView.dataSource = photosArrayDataSource;</p>

<h4>现在你不用不得不担心关于便利数组位置的索引。并且无论何时你想在tableview中展是一个数组你都可以重用这段代码。你也可以实现额外的方法。例如</h4>

<p>tableView:commitEditingStyle:forRowAtIndexPath: 并且分享代码到你所有的table view controllers.</p>

<h4>这是一个非常漂亮的<a href="http://www.objc.io/issue-1/testing-view-controllers.html#testing-datasource">分离测试例子</a> 并且再也不用担心重写它了。</h4>

<h4>在今年工作中编写的apps中，我们着重使用了核心数据。我们创建了一个简单的类代替依靠数组的牵强结果的控制器。它实现了所有的更新动画。头部内容和删除的逻辑，你可以创建这个对象的一个实例并且给他一个读写请求和一个方法快配置cell。剩下的自己就会运行。</h4>

<h4>未来，这同样可以扩展协议的途径。一个明显的候选例子是UICollectionViewDataSource。这给了你极大的灵活性，如果，在开发过程中某一时刻，你决定要一个UICollectionView，而不是一个UITableView，你几乎不必在你的视图控制器改变任何东西。你甚至可以让你的数据源支持两种协议。</h4>

<h3><center>移动主要逻辑到Model中去</center></h3>

<h4>这是一个视图控制器中支持找到user类归档属性的代码</h4>

<ul>
<li>(void)loadPriorities {
NSDate<em> now = [NSDate date];
NSString</em> formatString = @&ldquo;startDate &lt;= %@ AND endDate >= %@&rdquo;;
NSPredicate<em> predicate = [NSPredicate predicateWithFormat:formatString, now, now];
NSSet</em> priorities = [self.user.priorities filteredSetUsingPredicate:predicate];
self.priorities = [priorities allObjects];
}

<h4>无论无何，将这些代码移到user类的分类中去，它会变的更轻。象下面这个视图控制器的代码：</h4></li>
<li>(void)loadPriorities {
self.priorities = [user currentPriorities];
}

<h4>User+Extensions.m:</h4></li>
<li>(NSArray<em>)currentPriorities {
NSDate</em> now = [NSDate date];
NSString<em> formatString = @&ldquo;startDate &lt;= %@ AND endDate >= %@&rdquo;;
NSPredicate</em> predicate = [NSPredicate predicateWithFormat:formatString, now, now];
return [[self.priorities filteredSetUsingPredicate:predicate] allObjects];
}</li>
</ul>


<h4>一些代码不能被简单的移到model对象中 但是它仍然可以变的更轻通过相关的model代码。例如：</h4>

<h3><center>创建一个存储类 </center></h3>

<h4>在第一个版本的例子中，我们有一些加载数据从文件中并且解析它的代码。在视图控制器的代码：</h4>

<ul>
<li>(void)readArchive {
  NSBundle<em> bundle = [NSBundle bundleForClass:[self class]];
  NSURL </em>archiveURL = [bundle URLForResource:@&ldquo;photodata&rdquo;
                               withExtension:@&ldquo;bin&rdquo;];
  NSAssert(archiveURL != nil, @&ldquo;Unable to find archive in bundle.&rdquo;);
  NSData <em>data = [NSData dataWithContentsOfURL:archiveURL
                                       options:0
                                         error:NULL];
  NSKeyedUnarchiver </em>unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];
  <em>users = [unarchiver decodeObjectOfClass:[NSArray class] forKey:@&ldquo;users&rdquo;];
  </em>photos = [unarchiver decodeObjectOfClass:[NSArray class] forKey:@&ldquo;photos&rdquo;];
  [unarchiver finishDecoding];
}

<h4>视图控制器不必知道他是如何运转的。我们创建一个存储对象。通过分离他我们可以重用它，测试分离让我们的视图控制器更小。这个类可以实现数据加载，缓存，设置数据堆，这个类常常被成为服务层。</h4>

<h3><center>将网页服务的逻辑放到模型层</center></h3>

<h4>这个跟上边的是一样的话题：不要将网页服务逻辑放到视图控制器中，相反，分开到不同的类中，你的视图控制器可以掉调用方法通过回调处理，这是一个非常好的事情对于你处理所有的异常和错误</h4>

<h3><center> 通讯</cetner></h3>

<h4>另一件在视图控制器中经常发生的事情是与其他视图控制器，模型，和视图通信。这是一个视图控制器应该做的，他也是我们要实现的通过最少的代码。</h4>

<h4>有很多好的扩展技术在视图和模型对象中通信（例如KVO 和）无论怎样 视图通信常常是很小的一部分 我们经常遇到的问题一个视图有很多状态并且与相关的其他视图控制器相关。常常  设置一个状态到一个分离的对象中并且传递他通过视图控制器，则是所有的对象都会改变状态。他的优势是它是唯一一个再一个地方 并且我们不用纠结他的回调对象的调用。</h4>

<h3><center>总结</center></h3>

<h4>我们已经看到了创建更小视图控制器的技术。我们不追求尽可能的应用这些技术，因为我们只有一个目标：编写可维护的代码。通过了解这些模式，我们有选择更轻的视图控制器，使他们更清楚更好。</h4></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios开发 AudioToolBox框架音频播放的点滴(2)]]></title>
    <link href="http://javalipengfei.github.io/blog/2013/10/28/ioskai-fa-audiotoolboxkuang-jia-yin-pin-bo-fang-de-dian-di-2/"/>
    <updated>2013-10-28T17:57:00+08:00</updated>
    <id>http://javalipengfei.github.io/blog/2013/10/28/ioskai-fa-audiotoolboxkuang-jia-yin-pin-bo-fang-de-dian-di-2</id>
    <content type="html"><![CDATA[<h2>今天继续研究AudioToolBox的播放功能。</h2>

<h3>设置流的大小和读取包的个数</h3>

<!--more-->


<p>UInt32 maxPacketSize;</p>

<p>UInt32 propertySize = sizeof (maxPacketSize);</p>

<p>AudioFileGetProperty (                               // 1</p>

<pre><code>aqData.mAudioFile,                               // 2
kAudioFilePropertyPacketSizeUpperBound,          // 3
&amp;propertySize,                                   // 4
&amp;maxPacketSize                                   // 5
</code></pre>

<p>);</p>

<p>DeriveBufferSize (                                   // 6</p>

<pre><code>aqData.mDataFormat,                              // 7
maxPacketSize,                                   // 8
0.5,                                             // 9
&amp;aqData.bufferByteSize,                          // 10
&amp;aqData.mNumPacketsToRead                        // 11
</code></pre>

<p>);</p>

<ol>
<li>通过AudioFileGetProperty方法获取读取包的个数的最大值(大约)</li>
<li>音频文件引用</li>
<li>通过这个参数可以计算出最大的包数</li>
<li>这个kAudioFilePropertyPacketSizeUpperBound属性的字节的大小</li>
<li>你想播放的包的大小</li>
<li>设置流的大小和读取包的数量</li>
<li>你要播放数据的音频播放格式</li>
<li>前面估计的包的最大值</li>
<li>每个音频应该持有的秒数。</li>
<li> 设置读取流的字节数</li>
<li> 设置读取包的个数

<h3>为包中的数据结构开辟空间</h3></li>
</ol>


<p>bool isFormatVBR = (                                       // 1</p>

<pre><code>aqData.mDataFormat.mBytesPerPacket == 0 ||
aqData.mDataFormat.mFramesPerPacket == 0
</code></pre>

<p>);</p>

<p>if (isFormatVBR) {                                         // 2</p>

<pre><code>aqData.mPacketDescs =
  (AudioStreamPacketDescription*) malloc (
    aqData.mNumPacketsToRead * sizeof (AudioStreamPacketDescription)
  );
</code></pre>

<p>} else {                                                   // 3</p>

<pre><code>aqData.mPacketDescs = NULL;
</code></pre>

<p>}</p>

<ol>
<li>判断音频格式是VBR的合适CBR的</li>
<li>如果是VBR格式的，通过前面得到读取包的数量计算开辟空间的大小</li>
<li>对于CBR格式的不需要包的数据描述</li>
</ol>


<h3>设置Magic Cookie(不知道怎么翻译,其实是一种特殊音频格式)</h3>

<p>UInt32 cookieSize = sizeof (UInt32);                   // 1
bool couldNotGetProperty =                             // 2</p>

<pre><code>AudioFileGetPropertyInfo (                         // 3
    aqData.mAudioFile,                             // 4
    kAudioFilePropertyMagicCookieData,             // 5
    &amp;cookieSize,                                   // 6
    NULL                                           // 7
);
</code></pre>

<p>if (!couldNotGetProperty &amp;&amp; cookieSize) {              // 8</p>

<pre><code>char* magicCookie =
    (char *) malloc (cookieSize);
AudioFileGetProperty (                             // 9
    aqData.mAudioFile,                             // 10
    kAudioFilePropertyMagicCookieData,             // 11
    &amp;cookieSize,                                   // 12
    magicCookie                                    // 13
);
AudioQueueSetProperty (                            // 14
    aqData.mQueue,                                 // 15
    kAudioQueueProperty_MagicCookie,               // 16
    magicCookie,                                   // 17
    cookieSize                                     // 18
);
free (magicCookie);                                // 19
</code></pre>

<p>}
1. 初始化
2. 判断时候存在Magic Cookies
3. 获取Cookies
4. 参数不用说了
5. 。。。。
6. 。。。。
7. 。。。
8. 是否存在Magic cookies
9. 开辟空间
10. 音频文件
11. 参数。。。。
12. 。。。。
13. 。。。。。
14. 设置Magic Cookies
。。。。。。。</p>

<h3>为音频队列流开辟空间并且初始化</h3>

<p>aqData.mCurrentPacket = 0;                                // 1</p>

<p>for (int i = 0; i &lt; kNumberBuffers; ++i) {                // 2</p>

<pre><code>AudioQueueAllocateBuffer (                            // 3
    aqData.mQueue,                                    // 4
    aqData.bufferByteSize,                            // 5
    &amp;aqData.mBuffers[i]                               // 6
); 
HandleOutputBuffer (                                  // 7
    &amp;aqData,                                          // 8
    aqData.mQueue,                                    // 9
    aqData.mBuffers[i]                                // 10
);
</code></pre>

<p>}
2. 开辟3个音频流的空间
3. 开空间
4. 音频队列
5. 音频流的大小
6. 存储的音频流
7. 填充流到音频对列中
8. 客户端对象
9. 音频队列
10. 音频队列流</p>

<h3>设置音频队列的增益 这里是设置音量的增益</h3>

<p>Float32 gain = 1.0;                                       // 1</p>

<pre><code>// Optionally, allow user to override gain setting here
</code></pre>

<p>AudioQueueSetParameter (                                  // 2</p>

<pre><code>aqData.mQueue,                                        // 3
kAudioQueueParam_Volume,                              // 4
gain                                                  // 5
</code></pre>

<p>);</p>

<ol>
<li>初始化 范围是0—1</li>
<li>设置参数</li>
<li>音频队列</li>
<li>声音参数</li>
<li>增益参数</li>
</ol>


<h3>开始播放音频队列</h3>

<p>aqData.mIsRunning = true;                          // 1</p>

<p>AudioQueueStart (                                  // 2</p>

<pre><code>aqData.mQueue,                                 // 3
NULL                                           // 4
</code></pre>

<p>);</p>

<p>do {                                               // 5</p>

<pre><code>CFRunLoopRunInMode (                           // 6
    kCFRunLoopDefaultMode,                     // 7
    0.25,                                      // 8
    false                                      // 9
);
</code></pre>

<p>} while (aqData.mIsRunning);</p>

<p>CFRunLoopRunInMode (                               // 10</p>

<pre><code>kCFRunLoopDefaultMode,
1,
false
</code></pre>

<p>);</p>

<ol>
<li>是否停止播放的标志</li>
<li>开始音频队列的播放</li>
<li>音频队列</li>
<li>。。。</li>
<li>以后使我的下一个研究的对象</li>
</ol>


<h3>清空队列 释放空间</h3>

<p>AudioQueueDispose (                            // 1</p>

<pre><code>aqData.mQueue,                             // 2
true                                       // 3
</code></pre>

<p>);</p>

<p>AudioFileClose (aqData.mAudioFile);            // 4</p>

<p>free (aqData.mPacketDescs);</p>

<h2>至此 可以播放出来声音了 但是还是会有很多问题 后面我会慢慢去优化它。</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ios开发 AudioToolBox框架音频播放的点滴]]></title>
    <link href="http://javalipengfei.github.io/blog/2013/10/23/ioskai-fa-audiotoolboxkuang-jia-yin-pin-bo-fang-de-dian-di/"/>
    <updated>2013-10-23T17:24:00+08:00</updated>
    <id>http://javalipengfei.github.io/blog/2013/10/23/ioskai-fa-audiotoolboxkuang-jia-yin-pin-bo-fang-de-dian-di</id>
    <content type="html"><![CDATA[<blockquote><h4>今天研究了一下AudioToolBox苹果的音频开发框架。在我的不懈坚持下，终于可以放出声来了。但是仅仅是能放出声，对于一个追求强大的程序员来说这只是一个开始，虽然艰难，但是开始了 哈哈，<!--more-->下面呈上我对AudioToolBox播放音频的理解。</h4>

<h4>首先写代码之前要先了解流程才能事半功倍，下面是我用我的英语(你懂的)翻译的苹果官方网站的一些资料</h4>

<ol>
<li>首先定一个客户端机构体去管理状态，格式和路径等信息</li>
<li>写一个音频队列方法去执行音频的播放</li>
<li>写一个方法去计算音频队列流的大小</li>
<li>创建一个音频队列并且配置播放</li>
<li>为音频队列流开空间并且加入到队列，告诉音频队列开始播放，当做完这些，播放方法会调用回调方法这个音频队列播放完毕。</li>
<li>清除音频队列，并且释放资源。</li>
</ol>
</blockquote>

<h4>大概流程就这样的 我们只要按照这个流程去做就可以播放出美妙的音乐了 。我们来一一接受流程的步骤</h4>

<p> <!-- more —--></p>

<h2>首先介绍客户端结构的的数据结构</h2>

<p>struct AQPlayerState {</p>

<pre><code>AudioStreamBasicDescription  mDataFormat;                    // 1

AudioQueueRef                 mQueue;                         // 2

AudioQueueBufferRef           mBuffers[kNumberBuffers];       // 3

AudioFileID                   mAudioFile;                     // 4

UInt32                        bufferByteSize;                 // 5

SInt64                        mCurrentPacket;                 // 6

UInt32                        mNumPacketsToRead;              // 7

AudioStreamPacketDescription  *mPacketDescs;                  // 8

bool                          mIsRunning;                     // 9
</code></pre>

<p>};</p>

<ol>
<li>对音频流基本信息的描述(包含比特率，帧之类的信息，是音乐流中的含有的数据，你会通过方法获得其中的数据) 是一个结构体</li>
<li>音频队列</li>
<li>音频队列流</li>
<li>音频文件</li>
<li>音频队列中字节数的大小</li>
<li>包的索引值 意味着下一个包将会用于播放</li>
<li>读取的包的数量</li>
<li>音频流中包的基本信息的描述 也是一个结构体</li>
<li>判断当前的音频队列是否还在播放

<h4>这个结构体主要存储一些播放用的状态，数据格式等。</h4></li>
</ol>


<h2>写一个音频队列方法去执行音频的播放（这是一个回调方法）</h2>

<p>static void HandleOutputBuffer (</p>

<pre><code>void                 *aqData,                 // 1
AudioQueueRef        inAQ,                    // 2
AudioQueueBufferRef  inBuffer                 // 3
</code></pre>

<p>)</p>

<ol>
<li>上面创建的客户端机构体</li>
<li>音频队列</li>
<li>音频流</li>
</ol>


<h4>用于读取包中的数据到音频队列流中 在将音频队列流加入到音频队列中 AudioQueue一旦填满队列就会自动播放当播放完一个流的时候播放下一个音频流，当前流队列会推出来并且被填满数据。下面是具体实现方法：</h4>

<p>static void HandleOutputBuffer (</p>

<pre><code>void                *aqData,
AudioQueueRef       inAQ,
AudioQueueBufferRef inBuffer
</code></pre>

<p>) {</p>

<pre><code>AQPlayerState *pAqData = (AQPlayerState *) aqData;        // 1
if (pAqData-&gt;mIsRunning == 0) return;                     // 2
UInt32 numBytesReadFromFile;                              // 3
UInt32 numPackets = pAqData-&gt;mNumPacketsToRead;           // 4
AudioFileReadPackets (
    pAqData-&gt;mAudioFile,
    false,
    &amp;numBytesReadFromFile,
    pAqData-&gt;mPacketDescs, 
    pAqData-&gt;mCurrentPacket,
    &amp;numPackets,
    inBuffer-&gt;mAudioData 
);
if (numPackets &gt; 0) {                                     // 5
    inBuffer-&gt;mAudioDataByteSize = numBytesReadFromFile;  // 6
   AudioQueueEnqueueBuffer ( 
        pAqData-&gt;mQueue,
        inBuffer,
        (pAqData-&gt;mPacketDescs ? numPackets : 0),
        pAqData-&gt;mPacketDescs
    );
    pAqData-&gt;mCurrentPacket += numPackets;                // 7 
} else {
    AudioQueueStop (
        pAqData-&gt;mQueue,
        false
    );
    pAqData-&gt;mIsRunning = false; 
}
</code></pre>

<p>}</p>

<ol>
<li>客户端结构体 前面提到的。</li>
<li>检测队列是否还在播放</li>
<li>读取的字节的数量从文件中</li>
<li>读取的包</li>
<li>假如读取的包大于0 说明还有音频 要添加到音频队列中</li>
<li>设置读取的字节数量的大小</li>
<li>设置当前读取的报的位置</li>
</ol>


<h2>写一个方法去计算音频队列流的大小</h2>

<p>void DeriveBufferSize (</p>

<pre><code>AudioStreamBasicDescription ASBDesc,                            // 1
UInt32                      maxPacketSize,                       // 2
Float64                     seconds,                             // 3
UInt32                      *outBufferSize,                      // 4
UInt32                      *outNumPacketsToRead                 // 5
</code></pre>

<p>) {</p>

<pre><code>static const int maxBufferSize = 0x50000;                        // 6
static const int minBufferSize = 0x4000;                         // 7

if (ASBDesc.mFramesPerPacket != 0) {                             // 8
    Float64 numPacketsForTime =
        ASBDesc.mSampleRate / ASBDesc.mFramesPerPacket * seconds;
    *outBufferSize = numPacketsForTime * maxPacketSize;
} else {                                                         // 9
    *outBufferSize =
        maxBufferSize &gt; maxPacketSize ?
            maxBufferSize : maxPacketSize;
}

if (                                                             // 10
    *outBufferSize &gt; maxBufferSize &amp;&amp;
    *outBufferSize &gt; maxPacketSize
)
    *outBufferSize = maxBufferSize;
else {                                                           // 11
    if (*outBufferSize &lt; minBufferSize)
        *outBufferSize = minBufferSize;
}

*outNumPacketsToRead = *outBufferSize / maxPacketSize;           // 12
</code></pre>

<p>}</p>

<ol>
<li>音频流的数据描述结构 就是我们定义的那个客户端的mDataFormat</li>
<li><p>最大包的数量 可以根据UInt32 maxPacketSize;
UInt32 propertySize = sizeof (maxPacketSize);
AudioFileGetProperty (                               // 1</p>

<p>  aqData.mAudioFile,                               // 2</p>

<p>  kAudioFilePropertyPacketSizeUpperBound,          // 3</p>

<p>  &amp;propertySize,                                   // 4</p>

<p>  &amp;maxPacketSize                                   // 5
);这个方法获得大约的最大值(这里不用读取全部数据就可以得到最大的报数的大约值)</p></li>
<li>一个音频队列流持有的时间。0.5秒是一个不错的选择</li>
<li>读取的一个音频队列流的大小</li>
<li>读取的一个音频队列包的数量</li>
</ol>


<h2>创建一个音频队列并且配置播放</h2>

<h4>打开一个音频文件</h4>

<p>AQPlayerState aqData;                                   // 1</p>

<p>OSStatus result =</p>

<pre><code>AudioFileOpenURL (                                  // 2
    audioFileURL,                                   // 3
    fsRdPerm,                                       // 4
    0,                                              // 5
    &amp;aqData.mAudioFile                              // 6
);
</code></pre>

<p>CFRelease (audioFileURL);                               // 7</p>

<ol>
<li>创建一个客户端数据结构体存储音频数据</li>
<li>打开一个音频文件</li>
<li>音频文件的url（可以用(CFURLRef)url）方式传入</li>
<li>获得读取音频文件的的权限</li>
<li>文件类型提示 不知道可以直接传入0</li>
<li>客户端结构体中音乐文件的引用</li>
</ol>


<h4>获得音频流中的数据结构描述</h4>

<p>UInt32 dataFormatSize = sizeof (aqData.mDataFormat);    // 1</p>

<p>AudioFileGetProperty (                                  // 2</p>

<pre><code>aqData.mAudioFile,                                  // 3
kAudioFilePropertyDataFormat,                       // 4
&amp;dataFormatSize,                                    // 5
&amp;aqData.mDataFormat                                 // 6
</code></pre>

<p>);</p>

<h6>参数很简单 一目了然</h6>

<h4>创建音频播放队列</h4>

<p>AudioQueueNewOutput (</p>

<pre><code>&amp;aqData.mDataFormat,                             // 1    
HandleOutputBuffer,                              // 2
&amp;aqData,                                         // 3
CFRunLoopGetCurrent (),                          // 4
kCFRunLoopCommonModes,                           // 5
0,                                               // 6
&amp;aqData.mQueue                                   // 7
</code></pre>

<p>);</p>

<ol>
<li>音频流的数据描述</li>
<li>填充并播放流到队列的回调方法</li>
<li>客户端数据</li>
<li>当前线程</li>
<li>一般运行模式</li>
<li>必须设置为0 相当于初始化</li>
<li>将队列交给客户端结构体中的队列

<h1>今天先写到这 明天更精彩 吼吼</h1></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[美好的开始]]></title>
    <link href="http://javalipengfei.github.io/blog/2013/10/17/mei-hao-de-kai-shi/"/>
    <updated>2013-10-17T16:14:00+08:00</updated>
    <id>http://javalipengfei.github.io/blog/2013/10/17/mei-hao-de-kai-shi</id>
    <content type="html"><![CDATA[<blockquote><h4>历尽各种磨难，查阅了无数资料，终于把这个博客搭建起来了。仰天长啸中。。。。。。 哈哈。。。。。。</h4>

<h4>为什么要建立这个博客呢：<!--more--></h4>

<ol>
<li>我觉得建立一个博客，可以督导我每天都写一点东西，来记录生活、工作、学习，一个自己的生活纪录片.</li>
<li>通过它可以分享一下我学到的、感悟到的东西给这个世界，让世界听到我的声音</li>
<li>人非圣贤 孰能无过，有时候学到的感悟到不一定就是正确的，在这里可以与不同的声音进行交流、提高、成长。</li>
<li>。。。。。</li>
</ol>
</blockquote>

<h4>总之博客的好处让你无法拒绝它。最后感谢开源给我们带来的美好生活。启程喽。。。。。。</h4>
]]></content>
  </entry>
  
</feed>

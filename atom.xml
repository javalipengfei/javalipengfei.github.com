<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[漫步云端]]></title>
  <link href="http://javalipengfei.github.io/atom.xml" rel="self"/>
  <link href="http://javalipengfei.github.io/"/>
  <updated>2014-03-15T18:04:15+08:00</updated>
  <id>http://javalipengfei.github.io/</id>
  <author>
    <name><![CDATA[李鹏飞]]></name>
    <email><![CDATA[javalipengfei@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[测试视图控制器]]></title>
    <link href="http://javalipengfei.github.io/blog/2014/03/15/ce-shi-shi-tu-kong-zhi-qi/"/>
    <updated>2014-03-15T15:52:00+08:00</updated>
    <id>http://javalipengfei.github.io/blog/2014/03/15/ce-shi-shi-tu-kong-zhi-qi</id>
    <content type="html"><![CDATA[<h4>来源<a href="http://www.objc.io/issue-1/testing-view-controllers.html">objc.</a></h4>

<h4>作者<a href="https://twitter.com/danielboedewadt">Daniel Eggert</a></h4>

<h3>保持事情简单</h3>

<h4>测试简单的事情就会简单，测试复杂的事情就会变得复杂。正如我们在前几篇文章中指出的，保持事情小而且简单通常来说是非常好的。同时对于测试也很有帮助。他是双赢的结果。一起来看看<a href="https://en.wikipedia.org/wiki/Test-driven_development">测试驱动开发</a>，有些人喜欢他，有些人反之。我们不会去深入细节在这里，但是我们会说一下测试驱动开发，关于在你写代码之前你写的测试为你的代码。假如你对测试驱动开发好奇的话，查阅维基百科的资料你会发现重构和测试会很好的结合在一起。<!--more--></h4>

<h4>测试UI组件往往是棘手，因为这其中涉及了许多移动部件。很多时候，视图控制器交互涉及很多来自模型层和视图层的类。为了能测试这些视图控制器。我们需要隔离东西去进行。</h4>

<h4>让你高兴地是，通过我们描述的使得<a href="http://javalipengfei.github.io/blog/2013/12/02/geng-qing-xiao-de-shi-tu-kong-zhi-qi-fan-yi-1/">使视图控制器变轻</a>的技术让测试变得更简单。一般来说。假如你发现一些非常难测试的地方。这就会暗示你设计的不是很合理，并且你需要重构它，再一次参考这篇文章<a href="http://javalipengfei.github.io/blog/2013/12/02/geng-qing-xiao-de-shi-tu-kong-zhi-qi-fan-yi-1/">使视图控制器变轻</a>对于那些不合理的设计。总体的设计目标是有一个清晰的关注点分离，每一个类应该只做一件事情，并且把这件事情做好。那么这是就会测试一件事情了。</h4>

<h3>记住 ####:你增加越多的测试你得到的回报将会递减。首先增加简单的测试,从非常复杂的测试中分离出简单的测试，你会感觉到更舒服。</h3>

<h3>Mocking</h3>

<h4>当我们把事情拆分到很小的部分的时候。我们可以测试他拥有每一个类。我们测试这个类与其它类的交互。我们可以围绕这个类使用被称作mock 或者stub的测试方法。想像一个mock对象作为一个替换对象。我们测试这个类将会用替换对象代替真实对象进行交互。通过这个方法，我们可以致力于测试而且不用以来我们app的其他部分。</h4>

<h4>这个app的事例有一个我们测试的数组的数据源。这些数据将会在某一时刻出现在tableviw的cell上。在测试期间，我们没有tableivew。但是通过传第一个mock tableview，这样我们可以测试数据源在没有一个真实的tableview的时候。你会在下边看到。刚开始一点混乱。但是非常的好用和简单一旦你用它几次。</h4>

<h4>这最好的工具对于mocking 在Objective-c是被成为<a href="http://ocmock.org">OCMock</a>。这是一个非常成熟的项目，充分利用了Objective-C运行库的强大功能和灵活性。它把一些很酷的技巧，让通过mack 对象测试更有趣。</h4>

<h4>这数据源测试将在下边展示，更多的细节就是如何发挥这一切。</h4>

<h3>SenTestKit</h3>

<h4>这另外一个工具是我们将会使用的测试框架。这个框架作为开发者工具的一部分：ScenTestKit 来自<a href="http://www.sente.ch/">Sentn</a>.自1997年以来这个“恐龙“”已经存在了Objective-C的开发者 &ndash; 前十年的iPhone发布。如今，它的集成在Xcode中。</h4>

<h4>SenTestingKit 可以运行你的测试。通过SenTestKit，你会集成测试到你的类里面。你可以创建一个测试类为每一个你想测试的类。这个类将会有一个结尾名字在测试中。这个结尾名字会反映关于哪个类的测试。</h4>

<h4>在每一个测试类里面都有一个真实执行的测试类方法。这个测试方法名字必须一test开头作为触发器去运行这个test方法。有一个唯一的——setUP和-tearDown方法你可以重写在每一个测试类中。请记住，你的测试类只是一个类：它可以帮助你组织你的测试，可以自由地添加属性和helper方法。</h4>

<h4>一个漂亮的设计为测试创建一个漂亮的基类。我们放入一个合理的逻辑使我们的测试更简单更有效。导出<a href="https://github.com/objcio/issue-1-lighter-view-controllers/blob/master/PhotoDataTests/PhotoDataTestCase.h">事例工程</a>有一些简单的例子。我们不会用xcode模板去测试。我们的目标是简单高效，我们增加一个单独的.m文件。通过测试惯例有一个结尾名字。这个名字反映我们正在测试。</h4>

<h3>集成Xcode</h3>

<h4>测试内置到您选择的动态库以及资源包。假如你需要特别的测试资源针对你的测试。你需要将他们加入到测试的Target中，Xcode将会把他们放到资源包中。你可以取到他们通过NSBundle。这个事例工程实现了 -URLForResource:withExtension:的方法使它跟简单易用。</h4>

<h4>在Xcode中每一个scheme定义了相应的测试资源。⌘-R是运行APP，⌘-U是测试。测试如果已经运行，并且你的app已经启动。测试资源将会被干扰。测试运行的方式，您的应用程序实际上推出，而测试包注入。你可能不希望您的应用程序做太多，因为它可能与测试干扰。把下面的内容到你的应用程序委托：</h4>

<p>static BOOL isRunningTests(void) <strong>attribute</strong>((const));</p>

<ul>
<li><p>(BOOL)application:(UIApplication <em>)application <br/>
      didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions
{
  if (isRunningTests()) {
      return YES;
  }</p>

<p>  //
  // Normal logic goes here
  //</p>

<p>  return YES;
}</p></li>
</ul>


<p>static BOOL isRunningTests(void)
{</p>

<pre><code>NSDictionary* environment = [[NSProcessInfo processInfo] environment];
NSString* injectBundle = environment[@"XCInjectBundle"];
return [[injectBundle pathExtension] isEqualToString:@"octest"];
</code></pre>

<p>}</p>

<h4>编辑你的scheme为你的测试提供了很大的灵活性。你可以运行脚本在测试之前或者之后。你可以有多个测试资源。这对于大型项目非常有帮助。最重要的是，你可以打开和关闭单独的测试。这对于调试非常有用的测试——仅仅记得让他们恢复原状。也请记住，你可以在你的代码和测试用例设置断点和调试器会停在那里为执行测试。</h4>

<h3>下面就是代码实战了 我会在此一次博客中更新 敬请期待。。。。。。</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[清空TableView 的代码(翻译2)]]></title>
    <link href="http://javalipengfei.github.io/blog/2013/12/04/qing-kong-tableview-de-dai-ma-fan-yi-2/"/>
    <updated>2013-12-04T11:56:00+08:00</updated>
    <id>http://javalipengfei.github.io/blog/2013/12/04/qing-kong-tableview-de-dai-ma-fan-yi-2</id>
    <content type="html"><![CDATA[<h5>作者<a href="http://twitter.com/floriankugler">Florian Kugler</a></h5>

<h5>来源<a href="http://www.objc.io/issue-1/table-views.html">objc</a></h5>

<h4>tableView 对一个ios应用来说是一个多功能的组件。因此。一些代码直接的或间接的跟tableView的工作有关，比如说提供数据，更新tableView、控制他的行为和选中以及命名的反应，在这篇文章，<!--more-->我们将展现的技术是保持代码简洁和更好的代码结构。</h4>

<h3><center>UItableviewController VS. UIViewController </center></h3>

<h4>苹果提供了UItableViewController 作为tableVIews的专用ViewControler。UItableViewController 实现了很多能帮助我们避免重复一遍一遍的写样板代码的特性。在另一个方面，UItableViewController 被限制着管理一个铺满全屏的table view，然而，在很多案例中，这些是你需要的，如果他不是你需要的，有很多方法去解决这个问题，下面我门将会展示。</h4>

<h3><center>Table View Controllers 的特性</center></h3>

<h4>UItableVIewController 帮助你加在table view的数据当他第一次显示的时候。具体点。他帮助切换table view的编辑模式，反映键盘通知和一些小的特性象刷新scroll 的标识清空选中区域。为了这些特性能够工作，你要调用父类的视图事件方法（例如：viewWillAppear: and viewDidAppear:）在你的子类有可能被你重写的方法。</h4>

<h4>UItableViewController 有一个独特卖点就是在标准视图控制器之上。并且他支持苹果实现的滑动刷新功能。目前，这是唯一纪录的使用UIRefreshController 在tableVIewController里面。</h4>

<h4>苹果液晶定义了很多元素对于标准的table view的接口行为，如果你的app同意这些标准，它将是一个非常好的想法对于使用UItableViewController 避免写样板代码。</h4>

<h3><center>UItableViewControllers的限制</center></h3>

<h4>UITableViewController 的view必须设置为table view。如果你决定在你的屏幕的一边设置tableview，那你就尴尬了。</h4>

<h4>如果你已经定一个界面用.xib 文件，他将会非常简单转化为标准视图控制器，如果你用storyBoards，这时他会涉及到更多的步骤，通过sotryboards 你不能改变UItableViewController成为一个标准视图除非重新创建它。它意味着复制所有的内容到一个新的view controller并且再写一遍所有的东西。</h4>

<h4>最后 你需要添加你在转化中丢失的特性。大部分他们都是简单的单独一行状态在viewWillAppp或者viewDidAppear。切换编辑状态需要一个编辑tableview editting的属性的 action 方法，大部分工作在于重建键盘的支持。</h4>

<h4>在你按照这些方法做的时候，这有一个更简单的替代方案：分离关注点。</h4>

<h3><center>子视图控制器</center></h3>

<h4>相对于完全摆脱UItableViewController，你可以将UItableViewController作为子视图控制器加到别的视图控制器上。这时UItableViewController继续管理tableView 并且父视图可以管理你加在界面伤得任何你可能需要的视图。</h4>

<ul>
<li>(void)addPhotoDetailsTableView
{
  DetailsViewController *details = [[DetailsViewController alloc] init];
  details.photo = self.photo;
  details.delegate = self;
  [self addChildViewController:details];
  CGRect frame = self.view.bounds;
  frame.origin.y = 110;
  details.view.frame = frame;
  [self.view addSubview:details.view];  <br/>
  [details didMoveToParentViewController:self];
}

<h4>如果你用这个方式你必须建立一个通讯通道在子视图控制器和父试图控制器之间。例如，如果用户选择了一个cell在tableview，父视图控制器需要知道push另外的一个试图控制器，根据这个用例，常常使用代理协议的方式是最简洁的，你可以在父视图控制器实现这个协议。</h4></li>
</ul>


<p>@protocol DetailsViewControllerDelegate
&ndash; (void)didSelectPhotoAttributeWithKey:(NSString *)key;
@end</p>

<p>@interface PhotoViewController () <DetailsViewControllerDelegate>
@end</p>

<p>@implementation PhotoViewController
// &hellip;
&ndash; (void)didSelectPhotoAttributeWithKey:(NSString *)key
{</p>

<pre><code>DetailViewController *controller = [[DetailViewController alloc] init];
controller.key = key;
[self.navigationController pushViewController:controller animated:YES];
</code></pre>

<p>}
@end</p>

<h4>正如你所看见的，这个结构会带来一些开销对于试图控制器的通信换取关注点分离和更好的可重用性完全分离。从这个用例来看，它可以让事情变的更简单或者更复杂，这取决于你的考虑和决定</h4>

<h3><center> 分离关注点 </center></h3>

<h4>当表视图处理有很多种，涉及不同的任务，其中交叉模型，控制器和视图之间的边界。为了防止视图控制器成为所有这些任务的地方，我们会尝试找出尽可能多的任务，尽可能在更合适的地方。这有助于可读性，可维护性和可测试性。</h4>

<h4>这里描述的技术延伸和阐述后，在<a href="http://javalipengfei.github.io/blog/2013/12/02/geng-qing-xiao-de-shi-tu-kong-zhi-qi-fan-yi-1/">更轻小的视图控制器</a>演示的概念。请参考这篇文章如何因素我们的数据源和模型的逻辑。在表视图的背景下，我们将具体来看看如何视图控制器和视图之间分离关注点。</h4>

<h3><center>在cell和模型对象建立沟通桥梁</center></h3>

<h4>在某些时候，我们要交给我们想要显示到视图层的数据。由于我们仍然要保持模型和视图之间的明确分离，我们常常分离这个任务到tableview的数据源</h4>

<ul>
<li><p>(UITableViewCell * )tableView:(UITableView * )tableView
       cellForRowAtIndexPath:(NSIndexPath * )indexPath
{
  PhotoCell * cell = [tableView dequeueReusableCellWithIdentifier:@&ldquo;PhotoCell&rdquo;];</p>

<p>  Photo * photo = [self itemAtIndexPath:indexPath];
  cell.photoTitleLabel.text = photo.name;
  NSString* date = [self.dateFormatter stringFromDate:photo.creationDate];
  cell.photoDateLabel.text = date;
}</p>

<h4>我们可以将数据源中杂乱的代码设计一下，我们最好把它放到cell的分类中：</h4>

<p>@implementation PhotoCell (ConfigureForPhoto)</p></li>
<li><p>(void)configureForPhoto:(Photo * )photo
{
  self.photoTitleLabel.text = photo.name;
  NSString* date = [self.dateFormatter stringFromDate:photo.creationDate];
  self.photoDateLabel.text = date;
}</p></li>
</ul>


<p>@end</p>

<h4>我们数据源的代码会变的特别简洁</h4>

<ul>
<li>(UITableViewCell <em>)tableView:(UITableView </em>)tableView
       cellForRowAtIndexPath:(NSIndexPath <em>)indexPath
{
  PhotoCell </em>cell = [tableView dequeueReusableCellWithIdentifier:PhotoCellIdentifier];
  [cell configureForPhoto:[self itemAtIndexPath:indexPath]];
  return cell;
}</li>
</ul>


<h4>在我们的事例代码中table view的数据源<a href="http://javalipengfei.github.io/blog/2013/12/02/geng-qing-xiao-de-shi-tu-kong-zhi-qi-fan-yi-1/">是分离出我们控制器对象的</a>，我们初始化一个配置cell的方法块。用这种方式，这个方法快变的更简单：</h4>

<p>TableViewCellConfigureBlock block = ^(PhotoCell <em>cell, Photo </em>photo) {</p>

<pre><code>[cell configureForPhoto:photo];
</code></pre>

<p>};</p>

<h3><center>cell重用</center></h3>

<h4>在这个例子中，我们将介绍多种对象类型使用同一个cell类型，我们甚至可以更进一步增加cell的重用性。首先，我们定义一个使这个对象必须符合这个这个cell的类型的才能显示到cell的协议。这时我们简单的改变cell类中的配置方法来显示任何符合协议的cell。这些简单的步骤让cell从任何特定的模型对象种分离出来并且使他应用到不同的数据模型。</h4>

<h3><center>在cell类别种处理cell状态</center></h3>

<h4>假如我们想做一些额外的事情对于标准的变灰或者选中行为的，我们可以实现两个代理方法，他会改变点击cell的效果变成我们想要的。例如：</h4>

<ul>
<li><p>(void)tableView:(UITableView <em>)tableView
      didHighlightRowAtIndexPath:(NSIndexPath </em>)indexPath
{
  PhotoCell *cell = [tableView cellForRowAtIndexPath:indexPath];
  cell.photoTitleLabel.shadowColor = [UIColor darkGrayColor];
  cell.photoTitleLabel.shadowOffset = CGSizeMake(3, 3);
}</p></li>
<li><p>(void)tableView:(UITableView <em>)tableView
      didUnhighlightRowAtIndexPath:(NSIndexPath </em>)indexPath
{
  PhotoCell *cell = [tableView cellForRowAtIndexPath:indexPath];
  cell.photoTitleLabel.shadowColor = nil;
}</p></li>
</ul>


<h4>然而，这两个委托方法的实现又依赖于对cell是如何实现的具体知识。如果我们想换出cell或重新设计它以不同的方式，我们也要有适应的委托代码。这个实现的细节被完成通过实现这个代理方法。相反，我们应该把这个逻辑进入cell本身。</h4>

<p>@implementation PhotoCell
// &hellip;
&ndash; (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated
{</p>

<pre><code>[super setHighlighted:highlighted animated:animated];
if (highlighted) {
    self.photoTitleLabel.shadowColor = [UIColor darkGrayColor];
    self.photoTitleLabel.shadowOffset = CGSizeMake(3, 3);
} else {
    self.photoTitleLabel.shadowColor = nil;
}
</code></pre>

<p>}
@end</p>

<h4>一般来说，我们努力分离视图层的详细实现从控制层，代理必须知道一个视图的不同状态，但是他可以不知道关于如何改变视图树或者如何获取一些子视图的的正确属性。所有的逻辑应该封装到视图里面，对外只需要提供一个简单的接口。</h4>

<h3><center>处理多变的cell类型</center></h3>

<h4>如果你有不同的cell类型在tableView，这数据源的方法很快会失控。在我们的用例应用种我们有两个不同类型，一个用来显示星级的、一个用来显示键值对的。为了分离代码处理这些cell类型，数据源方法简单的分离了专门方法的请求对于不同的cell类型。</h4>

<ul>
<li><p>(UITableViewCell <em>)tableView:(UITableView </em>)tableView<br/>
       cellForRowAtIndexPath:(NSIndexPath <em>)indexPath
{
  NSString </em>key = self.keys[(NSUInteger) indexPath.row];
  id value = [self.photo valueForKey:key];
  UITableViewCell *cell;
  if ([key isEqual:PhotoRatingKey]) {
      cell = [self cellForRating:value indexPath:indexPath];
  } else {
      cell = [self detailCellForKey:key value:value];
  }
  return cell;
}</p></li>
<li><p>(RatingCell <em>)cellForRating:(NSNumber </em>)rating
                  indexPath:(NSIndexPath *)indexPath
{
  // &hellip;
}</p></li>
<li><p>(UITableViewCell <em>)detailCellForKey:(NSString </em>)key
                              value:(id)value
{
  // &hellip;
}</p></li>
</ul>


<h3><center>表格编辑</center></h3>

<h4>tableview提供了简单易用的编辑特性，允许简单的重新排序和删除cell。这这些事件中，tableview的数据源得到了代理方法的通知，因此 我们常常看到主要的逻辑在这些代理方法中去改数据。</h4>

<h4>更改数据很明显使模型层的任务。模型层应该提供例如重新排序和删除的接口以便于我们可以从数据源方法调用。通过这种方法，这个控制层充当视图和模型的协调的角色，不用去知道模型层的详细实现细节。还有一个好处，这个模型层的逻辑也变的简单测试，因为他不会与其他试图控制器有交织。</h4>

<h3><center>总结</center></h3>

<h4>TableVIewController（或者其他控制器对象）大部分使扮演一个交流和调节的角色在模型对象和试图对象之间，如果你坚持这个思想，代理和数据源方法将会变的更小并且包含更简单的模版代码.</h4>

<h4>这么做不仅仅使减少了大小和降低了TableViewController的复杂性。而且他使得主要的逻辑和视图逻辑等多了放到了合适的地方。上边和下边的控制层实现细节都封装到了一个简单的接口中，它最终使理解代码和他们之间合作变的更简单。</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[更轻小的视图控制器(翻译1)]]></title>
    <link href="http://javalipengfei.github.io/blog/2013/12/02/geng-qing-xiao-de-shi-tu-kong-zhi-qi-fan-yi-1/"/>
    <updated>2013-12-02T17:24:00+08:00</updated>
    <id>http://javalipengfei.github.io/blog/2013/12/02/geng-qing-xiao-de-shi-tu-kong-zhi-qi-fan-yi-1</id>
    <content type="html"><![CDATA[<h4>作者 <a href="http://twitter.com/chriseidhof">Chris Eidhof</a></h4>

<h4><a href="http://www.objc.io/issue-1/lighter-view-controllers.html">原文</a></h4>

<h4>视图控制器常常是IOS工程中最大的文件，并且它包含了一些以不必要方式存在的代码。通常，视图控制器是代码重用最少的部分。我们寻找使试图控制器变小变轻的技术，使代码提高重用，移动代码到更合适的地方。</h4>

<h4>这是一个托管在github的一个<a href="https://github.com/objcio/issue-1-lighter-view-controllers">例子</a></h4>

<h3><center>分离数据源和其他的协议</center></h3>

<!-- more -->


<h4>让视图控制器变的更轻的最好的技术就是将UITableViewDataSource的部分从你的代码中移动到自己的类中。假如你曾经一次这么做过，你将会看到模式和创建一个可以重用的类。</h4>

<h3>例如 在我们的事例工程中，有一个PhotosViewController有如下的方法</h3>

<p> pragma mark Pragma</p>

<ul>
<li><p>(Photo<em>)photoAtIndexPath:(NSIndexPath</em>)indexPath {
  return photos[(NSUInteger)indexPath.row];
}</p></li>
<li><p>(NSInteger)tableView:(UITableView*)tableView
numberOfRowsInSection:(NSInteger)section {
  return photos.count;
}</p></li>
<li><p>(UITableViewCell<em>)tableView:(UITableView</em>)tableView
      cellForRowAtIndexPath:(NSIndexPath<em>)indexPath {
  PhotoCell</em> cell = [tableView dequeueReusableCellWithIdentifier:PhotoCellIdentifier
                                                    forIndexPath:indexPath];
  Photo* photo = [self photoAtIndexPath:indexPath];
  cell.label.text = photo.name;
  return cell;
}</p>

<h4>这些代码通过数组做了一些事情。他们当中的具体的photos是被视图控制器管理的。所以让我们尝试移动与数组相关的代码到我们自己的类中。我们用一个方法块配置cell ，也可以用代理去做。根据的你的用例去选择和尝试。</h4>

<p>@implementation ArrayDataSource</p></li>
<li><p>(id)itemAtIndexPath:(NSIndexPath*)indexPath {
  return items[(NSUInteger)indexPath.row];
}</p></li>
<li><p>(NSInteger)tableView:(UITableView*)tableView
numberOfRowsInSection:(NSInteger)section {
  return items.count;
}</p></li>
<li><p>(UITableViewCell<em>)tableView:(UITableView</em>)tableView
      cellForRowAtIndexPath:(NSIndexPath*)indexPath {
  id cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier
                                            forIndexPath:indexPath];
  id item = [self itemAtIndexPath:indexPath];
  configureCellBlock(cell,item);
  return cell;
}</p></li>
</ul>


<p>@end</p>

<h4>这三个方法在你的视图控制器中可以运行 并且代替ni场jain的的一个对象并且设置他的数据源。</h4>

<p>void (^configureCell)(PhotoCell<em>, Photo</em>) = ^(PhotoCell<em> cell, Photo</em> photo) {
   cell.label.text = photo.name;
};
photosArrayDataSource = [[ArrayDataSource alloc] initWithItems:photos</p>

<pre><code>                                            cellIdentifier:PhotoCellIdentifier
                                        configureCellBlock:configureCell];
</code></pre>

<p>self.tableView.dataSource = photosArrayDataSource;</p>

<h4>现在你不用不得不担心关于便利数组位置的索引。并且无论何时你想在tableview中展是一个数组你都可以重用这段代码。你也可以实现额外的方法。例如</h4>

<p>tableView:commitEditingStyle:forRowAtIndexPath: 并且分享代码到你所有的table view controllers.</p>

<h4>这是一个非常漂亮的<a href="http://www.objc.io/issue-1/testing-view-controllers.html#testing-datasource">分离测试例子</a> 并且再也不用担心重写它了。</h4>

<h4>在今年工作中编写的apps中，我们着重使用了核心数据。我们创建了一个简单的类代替依靠数组的牵强结果的控制器。它实现了所有的更新动画。头部内容和删除的逻辑，你可以创建这个对象的一个实例并且给他一个读写请求和一个方法快配置cell。剩下的自己就会运行。</h4>

<h4>未来，这同样可以扩展协议的途径。一个明显的候选例子是UICollectionViewDataSource。这给了你极大的灵活性，如果，在开发过程中某一时刻，你决定要一个UICollectionView，而不是一个UITableView，你几乎不必在你的视图控制器改变任何东西。你甚至可以让你的数据源支持两种协议。</h4>

<h3><center>移动主要逻辑到Model中去</center></h3>

<h4>这是一个视图控制器中支持找到user类归档属性的代码</h4>

<ul>
<li>(void)loadPriorities {
NSDate<em> now = [NSDate date];
NSString</em> formatString = @&ldquo;startDate &lt;= %@ AND endDate >= %@&rdquo;;
NSPredicate<em> predicate = [NSPredicate predicateWithFormat:formatString, now, now];
NSSet</em> priorities = [self.user.priorities filteredSetUsingPredicate:predicate];
self.priorities = [priorities allObjects];
}

<h4>无论无何，将这些代码移到user类的分类中去，它会变的更轻。象下面这个视图控制器的代码：</h4></li>
<li>(void)loadPriorities {
self.priorities = [user currentPriorities];
}

<h4>User+Extensions.m:</h4></li>
<li>(NSArray<em>)currentPriorities {
NSDate</em> now = [NSDate date];
NSString<em> formatString = @&ldquo;startDate &lt;= %@ AND endDate >= %@&rdquo;;
NSPredicate</em> predicate = [NSPredicate predicateWithFormat:formatString, now, now];
return [[self.priorities filteredSetUsingPredicate:predicate] allObjects];
}</li>
</ul>


<h4>一些代码不能被简单的移到model对象中 但是它仍然可以变的更轻通过相关的model代码。例如：</h4>

<h3><center>创建一个存储类 </center></h3>

<h4>在第一个版本的例子中，我们有一些加载数据从文件中并且解析它的代码。在视图控制器的代码：</h4>

<ul>
<li>(void)readArchive {
  NSBundle<em> bundle = [NSBundle bundleForClass:[self class]];
  NSURL </em>archiveURL = [bundle URLForResource:@&ldquo;photodata&rdquo;
                               withExtension:@&ldquo;bin&rdquo;];
  NSAssert(archiveURL != nil, @&ldquo;Unable to find archive in bundle.&rdquo;);
  NSData <em>data = [NSData dataWithContentsOfURL:archiveURL
                                       options:0
                                         error:NULL];
  NSKeyedUnarchiver </em>unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];
  <em>users = [unarchiver decodeObjectOfClass:[NSArray class] forKey:@&ldquo;users&rdquo;];
  </em>photos = [unarchiver decodeObjectOfClass:[NSArray class] forKey:@&ldquo;photos&rdquo;];
  [unarchiver finishDecoding];
}

<h4>视图控制器不必知道他是如何运转的。我们创建一个存储对象。通过分离他我们可以重用它，测试分离让我们的视图控制器更小。这个类可以实现数据加载，缓存，设置数据堆，这个类常常被成为服务层。</h4>

<h3><center>将网页服务的逻辑放到模型层</center></h3>

<h4>这个跟上边的是一样的话题：不要将网页服务逻辑放到视图控制器中，相反，分开到不同的类中，你的视图控制器可以掉调用方法通过回调处理，这是一个非常好的事情对于你处理所有的异常和错误</h4>

<h3><center> 通讯</cetner></h3>

<h4>另一件在视图控制器中经常发生的事情是与其他视图控制器，模型，和视图通信。这是一个视图控制器应该做的，他也是我们要实现的通过最少的代码。</h4>

<h4>有很多好的扩展技术在视图和模型对象中通信（例如KVO 和）无论怎样 视图通信常常是很小的一部分 我们经常遇到的问题一个视图有很多状态并且与相关的其他视图控制器相关。常常  设置一个状态到一个分离的对象中并且传递他通过视图控制器，则是所有的对象都会改变状态。他的优势是它是唯一一个再一个地方 并且我们不用纠结他的回调对象的调用。</h4>

<h3><center>总结</center></h3>

<h4>我们已经看到了创建更小视图控制器的技术。我们不追求尽可能的应用这些技术，因为我们只有一个目标：编写可维护的代码。通过了解这些模式，我们有选择更轻的视图控制器，使他们更清楚更好。</h4></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios开发 AudioToolBox框架音频播放的点滴(2)]]></title>
    <link href="http://javalipengfei.github.io/blog/2013/10/28/ioskai-fa-audiotoolboxkuang-jia-yin-pin-bo-fang-de-dian-di-2/"/>
    <updated>2013-10-28T17:57:00+08:00</updated>
    <id>http://javalipengfei.github.io/blog/2013/10/28/ioskai-fa-audiotoolboxkuang-jia-yin-pin-bo-fang-de-dian-di-2</id>
    <content type="html"><![CDATA[<h2>今天继续研究AudioToolBox的播放功能。</h2>

<h3>设置流的大小和读取包的个数</h3>

<!--more-->


<p>UInt32 maxPacketSize;</p>

<p>UInt32 propertySize = sizeof (maxPacketSize);</p>

<p>AudioFileGetProperty (                               // 1</p>

<pre><code>aqData.mAudioFile,                               // 2
kAudioFilePropertyPacketSizeUpperBound,          // 3
&amp;propertySize,                                   // 4
&amp;maxPacketSize                                   // 5
</code></pre>

<p>);</p>

<p>DeriveBufferSize (                                   // 6</p>

<pre><code>aqData.mDataFormat,                              // 7
maxPacketSize,                                   // 8
0.5,                                             // 9
&amp;aqData.bufferByteSize,                          // 10
&amp;aqData.mNumPacketsToRead                        // 11
</code></pre>

<p>);</p>

<ol>
<li>通过AudioFileGetProperty方法获取读取包的个数的最大值(大约)</li>
<li>音频文件引用</li>
<li>通过这个参数可以计算出最大的包数</li>
<li>这个kAudioFilePropertyPacketSizeUpperBound属性的字节的大小</li>
<li>你想播放的包的大小</li>
<li>设置流的大小和读取包的数量</li>
<li>你要播放数据的音频播放格式</li>
<li>前面估计的包的最大值</li>
<li>每个音频应该持有的秒数。</li>
<li> 设置读取流的字节数</li>
<li> 设置读取包的个数

<h3>为包中的数据结构开辟空间</h3></li>
</ol>


<p>bool isFormatVBR = (                                       // 1</p>

<pre><code>aqData.mDataFormat.mBytesPerPacket == 0 ||
aqData.mDataFormat.mFramesPerPacket == 0
</code></pre>

<p>);</p>

<p>if (isFormatVBR) {                                         // 2</p>

<pre><code>aqData.mPacketDescs =
  (AudioStreamPacketDescription*) malloc (
    aqData.mNumPacketsToRead * sizeof (AudioStreamPacketDescription)
  );
</code></pre>

<p>} else {                                                   // 3</p>

<pre><code>aqData.mPacketDescs = NULL;
</code></pre>

<p>}</p>

<ol>
<li>判断音频格式是VBR的合适CBR的</li>
<li>如果是VBR格式的，通过前面得到读取包的数量计算开辟空间的大小</li>
<li>对于CBR格式的不需要包的数据描述</li>
</ol>


<h3>设置Magic Cookie(不知道怎么翻译,其实是一种特殊音频格式)</h3>

<p>UInt32 cookieSize = sizeof (UInt32);                   // 1
bool couldNotGetProperty =                             // 2</p>

<pre><code>AudioFileGetPropertyInfo (                         // 3
    aqData.mAudioFile,                             // 4
    kAudioFilePropertyMagicCookieData,             // 5
    &amp;cookieSize,                                   // 6
    NULL                                           // 7
);
</code></pre>

<p>if (!couldNotGetProperty &amp;&amp; cookieSize) {              // 8</p>

<pre><code>char* magicCookie =
    (char *) malloc (cookieSize);
AudioFileGetProperty (                             // 9
    aqData.mAudioFile,                             // 10
    kAudioFilePropertyMagicCookieData,             // 11
    &amp;cookieSize,                                   // 12
    magicCookie                                    // 13
);
AudioQueueSetProperty (                            // 14
    aqData.mQueue,                                 // 15
    kAudioQueueProperty_MagicCookie,               // 16
    magicCookie,                                   // 17
    cookieSize                                     // 18
);
free (magicCookie);                                // 19
</code></pre>

<p>}
1. 初始化
2. 判断时候存在Magic Cookies
3. 获取Cookies
4. 参数不用说了
5. 。。。。
6. 。。。。
7. 。。。
8. 是否存在Magic cookies
9. 开辟空间
10. 音频文件
11. 参数。。。。
12. 。。。。
13. 。。。。。
14. 设置Magic Cookies
。。。。。。。</p>

<h3>为音频队列流开辟空间并且初始化</h3>

<p>aqData.mCurrentPacket = 0;                                // 1</p>

<p>for (int i = 0; i &lt; kNumberBuffers; ++i) {                // 2</p>

<pre><code>AudioQueueAllocateBuffer (                            // 3
    aqData.mQueue,                                    // 4
    aqData.bufferByteSize,                            // 5
    &amp;aqData.mBuffers[i]                               // 6
); 
HandleOutputBuffer (                                  // 7
    &amp;aqData,                                          // 8
    aqData.mQueue,                                    // 9
    aqData.mBuffers[i]                                // 10
);
</code></pre>

<p>}
2. 开辟3个音频流的空间
3. 开空间
4. 音频队列
5. 音频流的大小
6. 存储的音频流
7. 填充流到音频对列中
8. 客户端对象
9. 音频队列
10. 音频队列流</p>

<h3>设置音频队列的增益 这里是设置音量的增益</h3>

<p>Float32 gain = 1.0;                                       // 1</p>

<pre><code>// Optionally, allow user to override gain setting here
</code></pre>

<p>AudioQueueSetParameter (                                  // 2</p>

<pre><code>aqData.mQueue,                                        // 3
kAudioQueueParam_Volume,                              // 4
gain                                                  // 5
</code></pre>

<p>);</p>

<ol>
<li>初始化 范围是0—1</li>
<li>设置参数</li>
<li>音频队列</li>
<li>声音参数</li>
<li>增益参数</li>
</ol>


<h3>开始播放音频队列</h3>

<p>aqData.mIsRunning = true;                          // 1</p>

<p>AudioQueueStart (                                  // 2</p>

<pre><code>aqData.mQueue,                                 // 3
NULL                                           // 4
</code></pre>

<p>);</p>

<p>do {                                               // 5</p>

<pre><code>CFRunLoopRunInMode (                           // 6
    kCFRunLoopDefaultMode,                     // 7
    0.25,                                      // 8
    false                                      // 9
);
</code></pre>

<p>} while (aqData.mIsRunning);</p>

<p>CFRunLoopRunInMode (                               // 10</p>

<pre><code>kCFRunLoopDefaultMode,
1,
false
</code></pre>

<p>);</p>

<ol>
<li>是否停止播放的标志</li>
<li>开始音频队列的播放</li>
<li>音频队列</li>
<li>。。。</li>
<li>以后使我的下一个研究的对象</li>
</ol>


<h3>清空队列 释放空间</h3>

<p>AudioQueueDispose (                            // 1</p>

<pre><code>aqData.mQueue,                             // 2
true                                       // 3
</code></pre>

<p>);</p>

<p>AudioFileClose (aqData.mAudioFile);            // 4</p>

<p>free (aqData.mPacketDescs);</p>

<h2>至此 可以播放出来声音了 但是还是会有很多问题 后面我会慢慢去优化它。</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ios开发 AudioToolBox框架音频播放的点滴]]></title>
    <link href="http://javalipengfei.github.io/blog/2013/10/23/ioskai-fa-audiotoolboxkuang-jia-yin-pin-bo-fang-de-dian-di/"/>
    <updated>2013-10-23T17:24:00+08:00</updated>
    <id>http://javalipengfei.github.io/blog/2013/10/23/ioskai-fa-audiotoolboxkuang-jia-yin-pin-bo-fang-de-dian-di</id>
    <content type="html"><![CDATA[<blockquote><h4>今天研究了一下AudioToolBox苹果的音频开发框架。在我的不懈坚持下，终于可以放出声来了。但是仅仅是能放出声，对于一个追求强大的程序员来说这只是一个开始，虽然艰难，但是开始了 哈哈，<!--more-->下面呈上我对AudioToolBox播放音频的理解。</h4>

<h4>首先写代码之前要先了解流程才能事半功倍，下面是我用我的英语(你懂的)翻译的苹果官方网站的一些资料</h4>

<ol>
<li>首先定一个客户端机构体去管理状态，格式和路径等信息</li>
<li>写一个音频队列方法去执行音频的播放</li>
<li>写一个方法去计算音频队列流的大小</li>
<li>创建一个音频队列并且配置播放</li>
<li>为音频队列流开空间并且加入到队列，告诉音频队列开始播放，当做完这些，播放方法会调用回调方法这个音频队列播放完毕。</li>
<li>清除音频队列，并且释放资源。</li>
</ol>
</blockquote>

<h4>大概流程就这样的 我们只要按照这个流程去做就可以播放出美妙的音乐了 。我们来一一接受流程的步骤</h4>

<p> <!-- more —--></p>

<h2>首先介绍客户端结构的的数据结构</h2>

<p>struct AQPlayerState {</p>

<pre><code>AudioStreamBasicDescription  mDataFormat;                    // 1

AudioQueueRef                 mQueue;                         // 2

AudioQueueBufferRef           mBuffers[kNumberBuffers];       // 3

AudioFileID                   mAudioFile;                     // 4

UInt32                        bufferByteSize;                 // 5

SInt64                        mCurrentPacket;                 // 6

UInt32                        mNumPacketsToRead;              // 7

AudioStreamPacketDescription  *mPacketDescs;                  // 8

bool                          mIsRunning;                     // 9
</code></pre>

<p>};</p>

<ol>
<li>对音频流基本信息的描述(包含比特率，帧之类的信息，是音乐流中的含有的数据，你会通过方法获得其中的数据) 是一个结构体</li>
<li>音频队列</li>
<li>音频队列流</li>
<li>音频文件</li>
<li>音频队列中字节数的大小</li>
<li>包的索引值 意味着下一个包将会用于播放</li>
<li>读取的包的数量</li>
<li>音频流中包的基本信息的描述 也是一个结构体</li>
<li>判断当前的音频队列是否还在播放

<h4>这个结构体主要存储一些播放用的状态，数据格式等。</h4></li>
</ol>


<h2>写一个音频队列方法去执行音频的播放（这是一个回调方法）</h2>

<p>static void HandleOutputBuffer (</p>

<pre><code>void                 *aqData,                 // 1
AudioQueueRef        inAQ,                    // 2
AudioQueueBufferRef  inBuffer                 // 3
</code></pre>

<p>)</p>

<ol>
<li>上面创建的客户端机构体</li>
<li>音频队列</li>
<li>音频流</li>
</ol>


<h4>用于读取包中的数据到音频队列流中 在将音频队列流加入到音频队列中 AudioQueue一旦填满队列就会自动播放当播放完一个流的时候播放下一个音频流，当前流队列会推出来并且被填满数据。下面是具体实现方法：</h4>

<p>static void HandleOutputBuffer (</p>

<pre><code>void                *aqData,
AudioQueueRef       inAQ,
AudioQueueBufferRef inBuffer
</code></pre>

<p>) {</p>

<pre><code>AQPlayerState *pAqData = (AQPlayerState *) aqData;        // 1
if (pAqData-&gt;mIsRunning == 0) return;                     // 2
UInt32 numBytesReadFromFile;                              // 3
UInt32 numPackets = pAqData-&gt;mNumPacketsToRead;           // 4
AudioFileReadPackets (
    pAqData-&gt;mAudioFile,
    false,
    &amp;numBytesReadFromFile,
    pAqData-&gt;mPacketDescs, 
    pAqData-&gt;mCurrentPacket,
    &amp;numPackets,
    inBuffer-&gt;mAudioData 
);
if (numPackets &gt; 0) {                                     // 5
    inBuffer-&gt;mAudioDataByteSize = numBytesReadFromFile;  // 6
   AudioQueueEnqueueBuffer ( 
        pAqData-&gt;mQueue,
        inBuffer,
        (pAqData-&gt;mPacketDescs ? numPackets : 0),
        pAqData-&gt;mPacketDescs
    );
    pAqData-&gt;mCurrentPacket += numPackets;                // 7 
} else {
    AudioQueueStop (
        pAqData-&gt;mQueue,
        false
    );
    pAqData-&gt;mIsRunning = false; 
}
</code></pre>

<p>}</p>

<ol>
<li>客户端结构体 前面提到的。</li>
<li>检测队列是否还在播放</li>
<li>读取的字节的数量从文件中</li>
<li>读取的包</li>
<li>假如读取的包大于0 说明还有音频 要添加到音频队列中</li>
<li>设置读取的字节数量的大小</li>
<li>设置当前读取的报的位置</li>
</ol>


<h2>写一个方法去计算音频队列流的大小</h2>

<p>void DeriveBufferSize (</p>

<pre><code>AudioStreamBasicDescription ASBDesc,                            // 1
UInt32                      maxPacketSize,                       // 2
Float64                     seconds,                             // 3
UInt32                      *outBufferSize,                      // 4
UInt32                      *outNumPacketsToRead                 // 5
</code></pre>

<p>) {</p>

<pre><code>static const int maxBufferSize = 0x50000;                        // 6
static const int minBufferSize = 0x4000;                         // 7

if (ASBDesc.mFramesPerPacket != 0) {                             // 8
    Float64 numPacketsForTime =
        ASBDesc.mSampleRate / ASBDesc.mFramesPerPacket * seconds;
    *outBufferSize = numPacketsForTime * maxPacketSize;
} else {                                                         // 9
    *outBufferSize =
        maxBufferSize &gt; maxPacketSize ?
            maxBufferSize : maxPacketSize;
}

if (                                                             // 10
    *outBufferSize &gt; maxBufferSize &amp;&amp;
    *outBufferSize &gt; maxPacketSize
)
    *outBufferSize = maxBufferSize;
else {                                                           // 11
    if (*outBufferSize &lt; minBufferSize)
        *outBufferSize = minBufferSize;
}

*outNumPacketsToRead = *outBufferSize / maxPacketSize;           // 12
</code></pre>

<p>}</p>

<ol>
<li>音频流的数据描述结构 就是我们定义的那个客户端的mDataFormat</li>
<li><p>最大包的数量 可以根据UInt32 maxPacketSize;
UInt32 propertySize = sizeof (maxPacketSize);
AudioFileGetProperty (                               // 1</p>

<p>  aqData.mAudioFile,                               // 2</p>

<p>  kAudioFilePropertyPacketSizeUpperBound,          // 3</p>

<p>  &amp;propertySize,                                   // 4</p>

<p>  &amp;maxPacketSize                                   // 5
);这个方法获得大约的最大值(这里不用读取全部数据就可以得到最大的报数的大约值)</p></li>
<li>一个音频队列流持有的时间。0.5秒是一个不错的选择</li>
<li>读取的一个音频队列流的大小</li>
<li>读取的一个音频队列包的数量</li>
</ol>


<h2>创建一个音频队列并且配置播放</h2>

<h4>打开一个音频文件</h4>

<p>AQPlayerState aqData;                                   // 1</p>

<p>OSStatus result =</p>

<pre><code>AudioFileOpenURL (                                  // 2
    audioFileURL,                                   // 3
    fsRdPerm,                                       // 4
    0,                                              // 5
    &amp;aqData.mAudioFile                              // 6
);
</code></pre>

<p>CFRelease (audioFileURL);                               // 7</p>

<ol>
<li>创建一个客户端数据结构体存储音频数据</li>
<li>打开一个音频文件</li>
<li>音频文件的url（可以用(CFURLRef)url）方式传入</li>
<li>获得读取音频文件的的权限</li>
<li>文件类型提示 不知道可以直接传入0</li>
<li>客户端结构体中音乐文件的引用</li>
</ol>


<h4>获得音频流中的数据结构描述</h4>

<p>UInt32 dataFormatSize = sizeof (aqData.mDataFormat);    // 1</p>

<p>AudioFileGetProperty (                                  // 2</p>

<pre><code>aqData.mAudioFile,                                  // 3
kAudioFilePropertyDataFormat,                       // 4
&amp;dataFormatSize,                                    // 5
&amp;aqData.mDataFormat                                 // 6
</code></pre>

<p>);</p>

<h6>参数很简单 一目了然</h6>

<h4>创建音频播放队列</h4>

<p>AudioQueueNewOutput (</p>

<pre><code>&amp;aqData.mDataFormat,                             // 1    
HandleOutputBuffer,                              // 2
&amp;aqData,                                         // 3
CFRunLoopGetCurrent (),                          // 4
kCFRunLoopCommonModes,                           // 5
0,                                               // 6
&amp;aqData.mQueue                                   // 7
</code></pre>

<p>);</p>

<ol>
<li>音频流的数据描述</li>
<li>填充并播放流到队列的回调方法</li>
<li>客户端数据</li>
<li>当前线程</li>
<li>一般运行模式</li>
<li>必须设置为0 相当于初始化</li>
<li>将队列交给客户端结构体中的队列

<h1>今天先写到这 明天更精彩 吼吼</h1></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[美好的开始]]></title>
    <link href="http://javalipengfei.github.io/blog/2013/10/17/mei-hao-de-kai-shi/"/>
    <updated>2013-10-17T16:14:00+08:00</updated>
    <id>http://javalipengfei.github.io/blog/2013/10/17/mei-hao-de-kai-shi</id>
    <content type="html"><![CDATA[<blockquote><h4>历尽各种磨难，查阅了无数资料，终于把这个博客搭建起来了。仰天长啸中。。。。。。 哈哈。。。。。。</h4>

<h4>为什么要建立这个博客呢：<!--more--></h4>

<ol>
<li>我觉得建立一个博客，可以督导我每天都写一点东西，来记录生活、工作、学习，一个自己的生活纪录片.</li>
<li>通过它可以分享一下我学到的、感悟到的东西给这个世界，让世界听到我的声音</li>
<li>人非圣贤 孰能无过，有时候学到的感悟到不一定就是正确的，在这里可以与不同的声音进行交流、提高、成长。</li>
<li>。。。。。</li>
</ol>
</blockquote>

<h4>总之博客的好处让你无法拒绝它。最后感谢开源给我们带来的美好生活。启程喽。。。。。。</h4>
]]></content>
  </entry>
  
</feed>
